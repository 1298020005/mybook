好的java教程

>http://c.biancheng.net/view/828.html  

### 校验判别

#### 判空类

##### 字符串判空

~~~java
Strei
if(StringUtils.isNotEmpty()){
    return error;
}
~~~

##### 整形判空

~~~java
Interger a=5;
if (null ==  a|| a == 0) {
   return error;
            }
~~~

##### 对象判空

~~~java
Car car=new car();
if (null == car ||!StringUtils.isNotNull(car.getId()))
~~~

##### List 判空

~~~java
List<String> car=new ArrayList<>();
if (null != car && !car.isEmpty()) {
   throw new EduException(ExceptionCodeEnum.QUESTION_TITLE_CANNOT_BE_REPEATED);
        }
~~~



#### 相等类

##### 字符串判断相等

~~~java
String a="3";
String b="4";
a.equals(b)
~~~

>https://blog.csdn.net/qq_32224047/article/details/112570412     翻转equals调用，equals方法被调用时字符串和对象的顺序

`equals`方法在`Object`抽象类中比较的是两个对象的引用地址是否相同，然而在String类型中，`equals`方法被重写了。因此String类型中的`equals`方法是比较当前字符串与传进来的字符串是否相同。

如果将对象放在前面，调用`equals`方法时，若对象为空，会报空指针异常；

但若是将字符串放在前面，也就是相当于判断这个字符串的值，即使它为空，也不会报错。因此可以总结为：报不报错主要看调用equals的对象是否为空。

所以在使用equals方法时，通常将字符串放在前面，比如`"userName" .equals` (对象),这样就不用担心对象为空了。先前写的虽然对`sortKey`对象做了不为空的判定，一方面多判断了一次，影响性能，另一反面也浪费了`equals`方法的使用。所以调换顺序更为规范。

##### 字符数组

~~~java
String s,t;
char[] str1 = s.toCharArray();
char[] str2 = t.toCharArray();
Arrays.equals(str1, str2);
~~~



#### 比较大小类

##### 字符串

~~~java
//姓名不超过50
String teacherName
teacherName.length() < 50
~~~

##### 数字比较大小

~~~java
int maxCount = 0, count = 0;
Math.max(maxCount, count);
~~~



#### 正则类

>https://leetcode-cn.com/problems/valid-phone-numbers/solution/zheng-ze-biao-da-shi-zhong-xian-ding-fu-yu-ding-we/



### Mybatis

~~~java
QueryWrapper<Car> qwSort = new QueryWrapper<>();
qwSort.lambda().eq(Car::getSortNum, sortNum);
qwSort.lambda().eq(Car::getType, 1);
List<Car> tQuestionBankOnlines1 = baseMapper.selectList(qwSort);
~~~



### 正则 

#### 是大于0小于等于100的正整数啊

```
Pattern p = Pattern.compile("(^[1-9][0-9]$|^0[1-9]$|^[1-9]$)|(^100$)");
String score ="0";
Matcher m = p.matcher(score);
if (m.matches()) {
    System.out.println("是大于0小于等于100的正整数啊");
}else{
    System.out.println("bus");
}
```

https://blog.csdn.net/u013066244/article/details/53197756



### 转换类  

#### 字符串和数字的转换 

~~~java
Integer.toBinaryString(
                Integer.parseInt(a, 2) + Integer.parseInt(b, 2)
~~~

如果字符串超过 3333 位，不能转化为 Integer
如果字符串超过 6565 位，不能转化为 Long
如果字符串超过 500000001500000001 位，不能转化为 BigInteger

#### int 转 string

~~~java
int i=1;
String a=String.valueOf(i)
~~~

#### 大小写转化

##### 小写字符转换为大写

~~~java
//运行结果为 A
System.out.println(Character.toUpperCase('a'));
~~~

##### 字符串中的所有字符全部转换成大写(属于String 类 )

~~~java
字符串名.toUpperCase()    // 将字符串中的字母全部转换为大写，非字母不受影响
~~~

##### 字符串中的所有字符全部转换成小写(属于String 类 )

~~~java
字符串名.toLowerCase()     // 将字符串中的字母全部转换为大写，非字母不受影响
~~~



### 反转类(二进制)

#### 字符串

~~~java
//初始化字符串
StringBuffer sgood = new StringBuffer();
//字符串反转
StringBuffer sgood_rev = new StringBuffer(sgood).reverse();
~~~

#### 反转底层二进制数组(注意是反转二进制)

~~~java
int n;
Integer.reverse(n);
~~~



### 数字类

#### 幂次方

~~~
int flag = 0;
// 26的flag次方
int s = (int) Math.pow(26, flag);
~~~

#### 运算符

>https://cloud.tencent.com/developer/article/1338265 运算符 

平方根

~~~java
int num=16;
//求num的平方 x=4 
int x = (int) Math.sqrt(num);
~~~



### 扩容类

#### 数组扩容

>https://blog.csdn.net/man_zuo/article/details/80146377	

### 获取值类

#### Map类 

##### 获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值

>https://www.runoob.com/java/java-hashmap-getordefault.html

```
//获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值
 HashMap<Character,Integer> hashmap=new HashMap<>();
hashmap.getOrDefault(Object key, V defaultValue)
```

##### 根据value获得key

>https://blog.csdn.net/u014259820/article/details/78835739

注意用法

~~~java
Map.Entry<Character, Integer> entry : position.entrySet()
~~~



#### 数组

##### 取最小值

~~~java
int min= Arrays.stream(nums).min().getAsInt();
~~~



#### 字符串类

##### 字符在字符串中第一次出现处的索引

>https://www.runoob.com/java/java-string-indexof.html

~~~java
String string = "aaa456ac";  
//查找指定字符是在字符串中的下标。在则返回所在字符串下标；不在则返回-1.  
System.out.println(string.indexOf("b")); // indexOf(String str); 返回结果：-1，"b"不存在  
 
// 从第四个字符位置开始往后继续查找，包含当前位置  
System.out.println(string.indexOf("a",3));//indexOf(String str, int fromIndex); 返回结果：6  
 
//（与之前的差别：上面的参数是 String 类型，下面的参数是 int 类型）参考数据：a-97,b-98,c-99  
 
// 从头开始查找是否存在指定的字符  
System.out.println(string.indexOf(99));//indexOf(int ch)；返回结果：7  
System.out.println(string.indexOf('c'));//indexOf(int ch)；返回结果：7  
 
//从fromIndex查找ch，这个是字符型变量，不是字符串。字符a对应的数字就是97。  
System.out.println(string.indexOf(97,3));//indexOf(int ch, int fromIndex); 返回结果：6  
System.out.println(string.indexOf('a',3));//indexOf(int ch, int fromIndex); 返回结果：6  
~~~



### 截取复制类

#### 数组截取

主要用于对一个已有的数组进行截取复制，复制出一个左闭右开区间的数组。

~~~java
// 此方法作用为 截取res数组从下表0到index 返回一个新数组
return Arrays.copyOfRange(res, 0, index);
~~~

#### 数组复制

~~~java
int[] score
int[] clone = score.clone();
~~~



### 排序类

#### 数组类排序(int char都可以)

~~~java
// int 也可以
char[] str1 = s.toCharArray();
Arrays.sort(str1);
~~~

#### hashmp排序(key和value)

>https://blog.csdn.net/xHibiki/article/details/82938480



### 未分类

#### 哈希表的数组替换

leetcode 448

用数组代替哈希
