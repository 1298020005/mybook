### 校验判别

#### 判空类

##### 字符串判空

~~~java
Strei
if(StringUtils.isNotEmpty()){
    return error;
}
~~~

##### 整形判空

~~~java
Interger a=5;
if (null ==  a|| a == 0) {
   return error;
            }
~~~

##### 对象判空

~~~java
Car car=new car();
if (null == car ||!StringUtils.isNotNull(car.getId()))
~~~

##### List 判空

~~~java
List<String> car=new ArrayList<>();
if (null != car && !car.isEmpty()) {
   throw new EduException(ExceptionCodeEnum.QUESTION_TITLE_CANNOT_BE_REPEATED);
        }
~~~



#### 相等类

字符串判断相等

~~~java
String a="3";
String b="4";
a.equals(b)
~~~

>https://blog.csdn.net/qq_32224047/article/details/112570412     翻转equals调用，equals方法被调用时字符串和对象的顺序

`equals`方法在`Object`抽象类中比较的是两个对象的引用地址是否相同，然而在String类型中，`equals`方法被重写了。因此String类型中的`equals`方法是比较当前字符串与传进来的字符串是否相同。

如果将对象放在前面，调用`equals`方法时，若对象为空，会报空指针异常；

但若是将字符串放在前面，也就是相当于判断这个字符串的值，即使它为空，也不会报错。因此可以总结为：报不报错主要看调用equals的对象是否为空。

所以在使用equals方法时，通常将字符串放在前面，比如`"userName" .equals` (对象),这样就不用担心对象为空了。先前写的虽然对`sortKey`对象做了不为空的判定，一方面多判断了一次，影响性能，另一反面也浪费了`equals`方法的使用。所以调换顺序更为规范。

#### 大小类

##### 字符串

~~~java
//姓名不超过50
String teacherName
teacherName.length() < 50
~~~



### Mybatis

~~~java
QueryWrapper<Car> qwSort = new QueryWrapper<>();
qwSort.lambda().eq(Car::getSortNum, sortNum);
qwSort.lambda().eq(Car::getType, 1);
List<Car> tQuestionBankOnlines1 = baseMapper.selectList(qwSort);
~~~



### 正则 

#### 是大于0小于等于100的正整数啊

```
Pattern p = Pattern.compile("(^[1-9][0-9]$|^0[1-9]$|^[1-9]$)|(^100$)");
String score ="0";
Matcher m = p.matcher(score);
if (m.matches()) {
    System.out.println("是大于0小于等于100的正整数啊");
}else{
    System.out.println("bus");
}
```

https://blog.csdn.net/u013066244/article/details/53197756



### 转换类  

字符串和数字的转换 

~~~java
Integer.toBinaryString(
                Integer.parseInt(a, 2) + Integer.parseInt(b, 2)
~~~

如果字符串超过 3333 位，不能转化为 Integer
如果字符串超过 6565 位，不能转化为 Long
如果字符串超过 500000001500000001 位，不能转化为 BigInteger



### 反转类

#### 字符串

~~~java
//初始化字符串
StringBuffer sgood = new StringBuffer();
//字符串反转
StringBuffer sgood_rev = new StringBuffer(sgood).reverse();
~~~

