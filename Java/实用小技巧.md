### 校验判别

#### 判空类

##### 字符串判空

~~~java
Strei
if(StringUtils.isNotEmpty()){
    return error;
}
~~~

##### 整形判空

~~~java
Interger a=5;
if (null ==  a|| a == 0) {
   return error;
            }
~~~

##### 对象判空

~~~java
Car car=new car();
if (null == car ||!StringUtils.isNotNull(car.getId()))
~~~

##### List 判空

~~~java
List<String> car=new ArrayList<>();
if (null != car && !car.isEmpty()) {
   throw new EduException(ExceptionCodeEnum.QUESTION_TITLE_CANNOT_BE_REPEATED);
        }
~~~



#### 相等类

##### 字符串判断相等

~~~java
String a="3";
String b="4";
a.equals(b)
~~~

>https://blog.csdn.net/qq_32224047/article/details/112570412     翻转equals调用，equals方法被调用时字符串和对象的顺序

`equals`方法在`Object`抽象类中比较的是两个对象的引用地址是否相同，然而在String类型中，`equals`方法被重写了。因此String类型中的`equals`方法是比较当前字符串与传进来的字符串是否相同。

如果将对象放在前面，调用`equals`方法时，若对象为空，会报空指针异常；

但若是将字符串放在前面，也就是相当于判断这个字符串的值，即使它为空，也不会报错。因此可以总结为：报不报错主要看调用equals的对象是否为空。

所以在使用equals方法时，通常将字符串放在前面，比如`"userName" .equals` (对象),这样就不用担心对象为空了。先前写的虽然对`sortKey`对象做了不为空的判定，一方面多判断了一次，影响性能，另一反面也浪费了`equals`方法的使用。所以调换顺序更为规范。

##### 字符数组

~~~java
String s,t;
char[] str1 = s.toCharArray();
char[] str2 = t.toCharArray();
Arrays.equals(str1, str2);
~~~



#### 比较大小类

##### 字符串

~~~java
//姓名不超过50
String teacherName
teacherName.length() < 50
~~~



#### 正则类

>https://leetcode-cn.com/problems/valid-phone-numbers/solution/zheng-ze-biao-da-shi-zhong-xian-ding-fu-yu-ding-we/



### Mybatis

~~~java
QueryWrapper<Car> qwSort = new QueryWrapper<>();
qwSort.lambda().eq(Car::getSortNum, sortNum);
qwSort.lambda().eq(Car::getType, 1);
List<Car> tQuestionBankOnlines1 = baseMapper.selectList(qwSort);
~~~



### 正则 

#### 是大于0小于等于100的正整数啊

```
Pattern p = Pattern.compile("(^[1-9][0-9]$|^0[1-9]$|^[1-9]$)|(^100$)");
String score ="0";
Matcher m = p.matcher(score);
if (m.matches()) {
    System.out.println("是大于0小于等于100的正整数啊");
}else{
    System.out.println("bus");
}
```

https://blog.csdn.net/u013066244/article/details/53197756



### 转换类  

#### 字符串和数字的转换 

~~~java
Integer.toBinaryString(
                Integer.parseInt(a, 2) + Integer.parseInt(b, 2)
~~~

如果字符串超过 3333 位，不能转化为 Integer
如果字符串超过 6565 位，不能转化为 Long
如果字符串超过 500000001500000001 位，不能转化为 BigInteger

#### int 转 string

~~~java
int i=1;
String a=String.valueOf(i)
~~~



### 反转类

#### 字符串

~~~java
//初始化字符串
StringBuffer sgood = new StringBuffer();
//字符串反转
StringBuffer sgood_rev = new StringBuffer(sgood).reverse();
~~~

#### 反转底层二进制数组(注意是反转二进制)

~~~java
int n;
Integer.reverse(n);
~~~



### 数字类

#### 幂次方

~~~
int flag = 0;
// 26的flag次方
int s = (int) Math.pow(26, flag);
~~~

#### 运算符

>https://cloud.tencent.com/developer/article/1338265 运算符 

平方根

~~~java
int num=16;
//求num的平方 x=4 
int x = (int) Math.sqrt(num);
~~~



### 扩容类

#### 数组扩容

>https://blog.csdn.net/man_zuo/article/details/80146377	

### 获取值类

#### Map类 

##### 获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值

>https://www.runoob.com/java/java-hashmap-getordefault.html

```
//获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值
 HashMap<Character,Integer> hashmap=new HashMap<>();
hashmap.getOrDefault(Object key, V defaultValue)
```

##### 根据value获得key

>https://blog.csdn.net/u014259820/article/details/78835739

注意用法

~~~java
Map.Entry<Character, Integer> entry : position.entrySet()
~~~



#### 数组

##### 取最小值

~~~java
int min= Arrays.stream(nums).min().getAsInt();
~~~



### 截取类

#### 数组截取

主要用于对一个已有的数组进行截取复制，复制出一个左闭右开区间的数组。

~~~java
// 此方法作用为 截取res数组从下表0到index 返回一个新数组
return Arrays.copyOfRange(res, 0, index);
~~~



### 排序类

#### 数组类排序(int char都可以)

~~~java
// int 也可以
char[] str1 = s.toCharArray();
Arrays.sort(str1);
~~~



### 未分类

#### 哈希表的数组替换

leetcode 448

用数组代替哈希
