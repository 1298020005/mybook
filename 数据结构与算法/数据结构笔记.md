[toc]

#### 待补充内容

1. 之前王道书上的笔记，包括习题集(工大的)，结合真实例题
2. 双向链表，
3. 循环队列待补充
4. 多维数组待补充，及广义表，串
5. 树集合例题
6. 图 最短路径 
7. 二叉排序树
8. 桶排序是否需要，确定算法是否需要学习。

#### 一 数据结构概述

>https://cwsong.lanzoui.com/b0cwh04lc 
>
>http://data.biancheng.net/view/35.html
>
>时隔多日从新学习数据结构。
>
>这次 侧重代码一点 
>
>偷偷学习数据结构，惊艳所有人！
>
>本笔记为杨彦祖结合多网站和王道考研整理而成，如有重复，就是咱抄的。

##### 1.1 什么是数据结构



![什么是数据结构](http://data.biancheng.net/uploads/allimg/181118/1-1Q11Q31302a3.gif)

 

数据结构，直白地理解，就是**研究数据的存储方式**。

我们知道，**数据存储只有一个目的，即为了方便后期对数据的再利用**，就如同我们使用数组

存储 `{1,2,3,4,5}` 是为了后期取得它们的加和值，无缘由的数据存储行为是对存储空间的不负责任。

因此，数据在计算机存储空间的存放，决不是胡乱的，这就要求我们选择一种好的方式来存储数据，而这也是数据结构的核心内容。

例如，一直以来大家面对的数据存储，都是类似存储 1、2、{a,b,c} 这样的问题，解决方式无疑是用变量或者数组对数据进行存储，即：

```c
int a=1;
int b=2;
char str[3]={'a','b','c'};
```

但是，如果要存储这样一组数据：{张亮，张平，张华，张群，张晶，张磊}，数据之间具有这样的关系：张亮是张平、张华和张群的父亲，同时张平还是张晶和张磊的父亲，数据之间的关系如 图1 所示：


![img](http://data.biancheng.net/uploads/allimg/171121/2-1G12114514Y03.png)

​								

<center>图 1 数据及数据之间的关系</center>


对于存储之间具有复杂关系的数据，如果还是用变量或数组来存储（比如用数组存储 {“张亮”,"张平",“张华”,"张群","张晶","张磊"} ），数据存储是没有问题，但是无法体现数据之间的逻辑关系，后期根本无法使用，显然不明智。

> 针对此类数据，数据结构中提供有专门的[树](http://data.biancheng.net/view/23.html)结构来存储这类数据。

再比如，导航无疑是出游旅行的必备神器，在我们程序员眼中，无论是哪款导航软件，其导航功能的实现都需要大量地图数据的支持。很明显，这些数据绝不是使用变量或数组进行存储的，那样对于数据的使用简直是个悲剧。

> 针对此类数据，数据结构提供了图存储结构，专门用于存储这类数据。

通过以上两个示例可以体会出，数据结构教会我们的绝不仅仅是如何存储 1、2、{a,b,c} 这样简单的数据，而是解决具有复杂关系的大量数据的存储问题。

因此，数据结构是什么? **我认为，数据结构是一门学科，它教会我们“如何存储具有复杂关系的数据更有助于后期对数据的再利用”。**

**本节概括** 

①数据结构，直白地理解，就是研究数据的存储方式

②数据存储只有一个目的，即为了方便后期对数据的再利用

③数据结构是一门学科，它教会我们“如何存储具有复杂关系的数据更有助于后期对数据的再利用

##### 1.2 数据结构到底学什么

 通过上节我们知道，数据结构是学习数据存储方式的一门学科，那么，数据存储方式有哪几种呢？本节将对数据结构的学习内容做一个简要的总结。

数据结构大致包含以下几种存储结构：

- 线性表，还可细分为顺序表、链表、栈和队列；
- [树](http://data.biancheng.net/view/23.html)结构，包括普通树，二叉树，线索二叉树等；
- 图存储结构；


下面对各种数据结构做详细讲解。

**线性表**

线性表结构存储的数据往往是可以依次排列的，就像小朋友手拉手，每位学生的前面和后面都仅有一个小朋友和他拉手，具备这种“一对一”关系的数据就可以使用线性表来存储。

![手拉手的小朋友](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH151411.gif)


例如，存储类似 {1,3,5,7,9} 这样的数据时，各元素依次排列，每个元素的前面和后边有且仅有一个元素与之相邻（除首元素和尾元素），因此可以使用线性表存储。

线性表并不是一种具体的存储结构，它包含顺序存储结构和链式存储结构，是顺序表和链表的统称。

**顺序表**

顺序表，简单地理解，就是常用的数组，只是换了个名字而已，例如使用顺序表存储 {1,3,5,7,9}，如图 1 所示：

![顺序表结构](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QI9559D.gif)

<center>图 1 顺序表结构</center>

由于顺序表结构的底层实现借助的就是数组，因此对于初学者来说，可以把顺序表完全等价为数组**，但实则不是这样。数据结构是研究数据存储方式的一门学科，它囊括的都是各种存储结构，而数组只是各种编程语言中的基本数据类型**，并不属于数据结构的范畴。

**链表**

我们知道，使用顺序表（底层实现靠数组）时，需要提前申请一定大小的存储空间，这块存储空间的物理地址是连续的，如图 1 所示。

链表则完全不同，使用链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的。

为了给各个数据块建立“依次排列”的关系，链表给各数据块增设一个指针，每个数据块的指针都指向下一个数据块（最后一个数据块的指针指向 NULL），就如同一个个小学生都伸手去拉住下一个小学生的手，这样，看似毫无关系的数据块就建立了“依次排列”的关系，也就形成了链表，如图 2 所示：

​                 

![链表结构](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH334H1.gif)

<center>图 2 链表结构</center>

**栈和队列**

栈和队列隶属于线性表，是特殊的线性表，因为它们对线性表中元素的进出做了明确的要求。

栈中的元素只能从线性表的一端进出（另一端封死），且要遵循“先入后出”的原则，即先进栈的元素后出栈。



![栈结构示意图](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH634D9.gif)

<center>图 3 栈结构示意图</center>


栈结构如图 3 所示，像一个木桶，栈中含有 3 个元素，分别是 A、B 和 C，从在栈中的状态可以看出 A 最先进的栈，然后 B 进栈，最后 C 进栈。根据“先进后出”的原则，3 个元素出栈的顺序应该是：C 最先出栈，然后 B 出栈，最后才是 A 出栈。

队列中的元素只能从线性表的一端进，从另一端出，且要遵循“先入先出”的特点，即先进队列的元素也要先出队列。


![队列结构示意图](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QHIJO.gif)

<center>图 4 队列结构示意图</center>

队列结构如图 4 所示，队列中有 3 个元素，分别是 A、B 和 C，从在队列中的状态可以看出是 A 先进队列，然后 B 进，最后 C 进。根据“先进先出”的原则，3 个元素出队列的顺序应该是 A 最先出队列，然后 B 出，最后 C 出。

**树存储结构**

树存储结构**适合存储具有“一对多**”关系的数据。

​                           																![家庭族谱](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QJJ0142.gif)     

<center>图 5 家庭族谱</center>


如图 5 所示，其中张平只有一个父亲，但他却有两（多）个孩子，这就是“一对多”的关系，满足这种关系的数据可以使用树存储结构。

**图存储结构**

图存储结构适合存储**具有“多对多”关系**的数据。


![图存储结构示意图](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QIFS44.gif)

<center>图 6 图存储结构示意图</center>

如图 6 所示，从 V1 可以到达 V2、V3、V4，同样，从 V2、V3、V4 也可以到达 V1，这就是“多对多”的关系，满足这种关系的数据可以使用图存储结构。

> 本节只是对数据结构中包含的各种存储结构做一个简要的介绍，各存储结构具体的实现会在后续文章中作详解介绍。



#### 二 线性表 

##### 1.1 什么是线性表 

线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线儿[串](http://data.biancheng.net/view/175.html)起来，再存储到物理空间中”。

!["一对一"逻辑关系的数据](http://data.biancheng.net/uploads/allimg/181120/1-1Q120214QJ63.gif)

<center>图1 "一对一"逻辑关系的数据</center>


如图 1 所示，这是一组具有“一对一”关系的数据，我们接下来采用线性表将其储存到物理空间中。

首先，用“一根线儿”把它们按照顺序“串”起来，如图 2 所示：


![img](http://data.biancheng.net/uploads/allimg/181120/1-1Q12021551W22.gif)

<center>图 2 数据的"线性"结构</center>


图 2 中，左侧是“串”起来的数据，右侧是空闲的物理空间。把这“一串儿”数据放置到物理空间，我们可以选择以下两种方式，如图 3 所示。


![两种线性存储结构](http://data.biancheng.net/uploads/allimg/181120/1-1Q120215009361.gif)

<center>图 3 两种线性存储结构



图 3a) 是多数人想到的存储方式，而图 3b) 却少有人想到。我们知道，**数据存储的成功与否，取决于是否能将数据完整地复原成它本来的样子**。如果把图 3a) 和图 3b) 线的一头扯起，你会发现数据的位置依旧没有发生改变（和图 1 一样)。因此可以认定，这两种存储方式都是正确的。

将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为线性存储结构（简称线性表）。

**使用线性表存储的数据，如同向数组中存储数据那样，要求数据类型必须一致**

> 也就是说，线性表存储的数据，要么全不都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。



**一 顺序存储结构和链式存储结构**

图 3 中我们可以看出，线性表存储数据可细分为以下 2 种：

1. 如图 3a) 所示，将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称顺序表）；
2. 如图 3b) 所示，数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称链表）；


也就是说，线性表存储结构可细分为顺序存储结构和链式存储结构。

**二 线性表常用术语**

数据结构中，一组数据中的每个个体被称为“数据元素”（简称“元素”）。例如，图 1 显示的这组数据，其中 1、2、3、4 和 5 都是这组数据钟的一个元素。

另外，对于具有“一对一”逻辑关系的数据，我们一直在用“某一元素的左侧（前边）或右侧（后边）”这样不专业的词，其实线性表中有更准确的术语：

- 某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；
- 某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；


以图 1 数据中的元素 3 来说，它的直接前驱是 2 ，此元素的前驱元素有 2 个，分别是 1 和 2；同理，此元素的直接后继是 4 ，后继元素也有 2 个，分别是 4 和 5。如图 4 所示：


![前驱和后继](http://data.biancheng.net/uploads/allimg/181120/1-1Q1202152464R.gif)

<center>图 4 前驱和后继</center>

##### 2.2 顺序表是什么 

顺序表，全名顺序存储结构，是线性表的一种。通过《线性表》一节的学习我们知道，线性表用于存储逻辑关系为“一对一”的数据，顺序表自然也不例外。

不仅如此，顺序表对数据的物理存储结构也有要求。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。

例如，使用顺序表存储集合 `{1,2,3,4,5}`，数据最终的存储状态如图1 所示：


![img](http://data.biancheng.net/uploads/allimg/181121/2-1Q121202555F0.gif)

<center>图 1 顺序存储结构示意图


由此我们可以得出，将“具有 '一对一' 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构。

通过观察图 1 中数据的存储状态，我们可以发现，顺序表存储数据同数组非常接近。其实，顺序表存储数据使用的就是数组。

>顺序表实现使用的是数组，但是两者性质不同，前者针对的是数据的存储，而后者是基本的数据类型

**一 顺序表的初始化**

使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：

1. 顺序表申请的存储容量；
2. 顺序表的长度，也就是表中存储数据元素的个数；

提示：正常状态下，顺序表申请的存储容量要大于顺序表的长度。

因此，我们需要自定义顺序表，C 语言实现代码如下：

```c
typedef struct Table{    
    int * head;//声明了一个名为head的长度不确定的数组，也叫“动态数组”    
    int length;//记录当前顺序表的长度    
    int size;//记录顺序表分配的存储容量
}table;
```

注意，head 是我们声明的一个未初始化的动态数组，不要只把它看做是普通的指针。

接下来开始学习顺序表的初始化，也就是初步建立一个顺序表。建立顺序表需要做如下工作：

- 给 head 动态数据申请足够大小的物理空间；
- 给 size 和 length 赋初值；


因此，C 语言实现代码如下：

```c
#define Size 5 //对Size进行宏定义，表示顺序表申请空间的大小
table initTable(){    
    table t;   
    t.head = (int*)malloc(Size * sizeof(int));//构造一个空的顺序表，动态申请存储空间   
    if (!t.head) //如果申请失败，作出提示并直接退出程序   
    {        printf("初始化失败");     
     exit(0);    }   
    t.length = 0;//空表的长度初始化为0   
    t.size = Size;//空表的初始存储空间为Size   
    return t;}
```

我们看到，整个顺序表初始化的过程被封装到了一个函数中，此函数返回值是一个已经初始化完成的顺序表。这样做的好处是增加了代码的可用性，也更加美观。与此同时，顺序表初始化过程中，要注意对物理空间的申请进行判断，对申请失败的情况进行处理，这里只进行了“输出提示信息和强制退出”的操作，可以根据你自己的需要对代码中的 if 语句进行改进。

通过在主函数中调用 initTable 语句，就可以成功创建一个空的顺序表，与此同时我们还可以试着向顺序表中添加一些元素，C 语言实现代码如下：

```c
#include <stdio.h>
#include <stdlib.h>  //malloc()、exit()
#define Size 5
typedef struct Table {
    int * head;
    int length;
    int size;
}table;
table initTable() {
    table t;
    t.head = (int*)malloc(Size * sizeof(int));
    if (!t.head)
    {
        printf("初始化失败");
        exit(0);
    }
    t.length = 0;
    t.size = Size;
    return t;
}
//输出顺序表中元素的函数
void displayTable(table t) {
    int i;
    for (i = 0; i < t.length; i++) {
        printf("%d ", t.head[i]);
    }
    printf("\n");
}
int main() {
    int i;
    table t = initTable();
    //向顺序表中添加元素
    for (i = 1; i <= Size; i++) {
        t.head[i - 1] = i;
        t.length++;
    }
    printf("顺序表中存储的元素分别是：\n");
    displayTable(t);
    return 0;
}
```

程序运行结果如下：

```shell
顺序表中存储的元素分别是：
1 2 3 4 5
```

可以看到，顺序表初始化成功。



##### 2.3 顺序表的基本操作 

我们学习了顺序表及初始化的过程，本节学习有关顺序表的一些基本操作，以及如何使用 C 语言实现它们。

###### 2.3.1 顺序表插入元素

向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：

1. 插入到顺序表的表头；
2. 在表的中间位置插入元素；
3. 尾随顺序表中已有元素，作为顺序表中的最后一个元素；


虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：

- 将要插入位置元素以及后续的元素整体向后移动一个位置；
- 将元素放到腾出来的位置上；


例如，在 `{1,2,3,4,5}` 的第 3 个位置上插入元素 6，实现过程如下：

- 遍历至顺序表存储第 3 个数据元素的位置，如图 1 所示：


![找到目标元素位置](http://data.biancheng.net/uploads/allimg/181122/2-1Q122201300X8.gif)

<center>图 1 找到目标元素位置</center>

- 将元素 3 以及后续元素 4 和 5 整体向后移动一个位置，如图 2 所示：


![将插入位置腾出](http://data.biancheng.net/uploads/allimg/181122/2-1Q122201355232.gif)

<center>图 2 将插入位置腾出</center>

- 将新元素 6 放入腾出的位置，如图 3 所示：


![插入目标元素](http://data.biancheng.net/uploads/allimg/181122/2-1Q12220142H50.gif)

<center>图 3 插入目标元素</center>


因此，顺序表插入数据元素的 C 语言实现代码如下：

```c
//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置
table addTable(table t, int elem, int add)
{
    int i;
    //①判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出）
    if (add > t.length + 1 || add < 1) {
        printf("插入位置有问题");
        return t;
    }
    //②做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请
    if (t.length == t.size) {
        t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int));
        if (!t.head) {
            printf("存储分配失败");
            return t;
        }
        t.size += 1;
    }
    //③插入操作，需要将从插入位置开始的后续元素，逐个后移
    for (i = t.length - 1; i >= add - 1; i--) {
        t.head[i + 1] = t.head[i];
    }
    //④后移完成后，直接将所需插入元素，添加到顺序表的相应位置
    t.head[add - 1] = elem;
    //⑤由于添加了元素，所以长度+1
    t.length++;	
    return t;
}
```

注意，**动态数组额外申请更多物理空间使用的是 realloc 函数。**并且，在实现后续元素整体后移的过程，**目标位置其实是有数据的，还是 3**，只是下一步新插入元素时会把旧元素直接覆盖。

>整体后裔只能从后像待插入位置顺序后移，反之不行。

###### 2.3.2  顺序表删除元素

从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。

后续元素整体前移一个位置，会直接将目标元素删除，可间接实现删除元素的目的。

例如，从 `{1,2,3,4,5}` 中删除元素 3 的过程如图 4 所示：


![img](http://data.biancheng.net/uploads/allimg/181122/2-1Q122201629521.gif)

<center>图 4 顺序表删除元素的过程示意图</center>


因此，顺序表删除元素的 C 语言实现代码为：

```c
table delTable(table t, int add) {
    int i;
    if (add > t.length || add < 1) {
        printf("被删除元素的位置有误");
        exit(0);
    }
    //删除操作
    for (i = add; i < t.length; i++) {
        t.head[i - 1] = t.head[i];
    }
    t.length--;
    return t;
}
```

###### 2.3.3 顺序表查找元素

顺序表中查找目标元素，可以使用多种查找算法实现，比如说[二分查找](http://data.biancheng.net/view/55.html)算法、插值查找算法等。

这里，我们选择[顺序查找](http://data.biancheng.net/view/54.html)算法，具体实现代码为：

```c
//查找函数，其中，elem表示要查找的数据元素的值
int selectTable(table t, int elem) {
    int i;
    for (i = 0; i < t.length; i++) {
        if (t.head[i] == elem) {
            return i + 1;
        }
    }
    return -1;//如果查找失败，返回-1
}
```

###### 2.3.4 顺序表更改元素

顺序表更改元素的实现过程是：

1. 找到目标元素；
2. 直接修改该元素的值；


顺序表更改元素的 C 语言实现代码为：

~~~c
//更改函数，其中，elem为要更改的元素，newElem为新的数据元素
table amendTable(table t, int elem, int newElem) {
    int add = selectTable(t, elem);
    t.head[add - 1] = newElem;//由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标
    return t;
}
~~~

以上是顺序表使用过程中最常用的基本操作，这里给出本节完整的实现代码：

~~~c
#include <stdio.h>
#include <stdlib.h>
#define Size 5
typedef struct Table {
    int * head;
    int length;
    int size;
}table;
table initTable() {
    table t;
    t.head = (int*)malloc(Size * sizeof(int));
    if (!t.head)
    {
        printf("初始化失败");
        exit(0);
    }
    t.length = 0;
    t.size = Size;
    return t;
}
table addTable(table t, int elem, int add)
{
    int i;
    if (add > t.length + 1 || add < 1) {
        printf("插入位置有问题");
        return t;
    }
    if (t.length >= t.size) {
        t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int));
        if (!t.head) {
            printf("存储分配失败");
        }
        t.size += 1;
    }
    for (i = t.length - 1; i >= add - 1; i--) {
        t.head[i + 1] = t.head[i];
    }
    t.head[add - 1] = elem;
    t.length++;
    return t;
}
table delTable(table t, int add) {
    int i;
    if (add > t.length || add < 1) {
        printf("被删除元素的位置有误");
        exit(0);
    }
    for (i = add; i < t.length; i++) {
        t.head[i - 1] = t.head[i];
    }
    t.length--;
    return t;
}
int selectTable(table t, int elem) {
    int i;
    for (i = 0; i < t.length; i++) {
        if (t.head[i] == elem) {
            return i + 1;
        }
    }
    return -1;
}
table amendTable(table t, int elem, int newElem) {
    int add = selectTable(t, elem);
    t.head[add - 1] = newElem;
    return t;
}
void displayTable(table t) {
    int i;
    for (i = 0; i < t.length; i++) {
        printf("%d ", t.head[i]);
    }
    printf("\n");
}
int main() {
    int i, add;
    table t1 = initTable();
    for (i = 1; i <= Size; i++) {
        t1.head[i - 1] = i;
        t1.length++;
    }
    printf("原顺序表：\n");
    displayTable(t1);

    printf("删除元素1:\n");
    t1 = delTable(t1, 1);
    displayTable(t1);

    printf("在第2的位置插入元素5:\n");
    t1 = addTable(t1, 5, 2);
    displayTable(t1);

    printf("查找元素3的位置:\n");
    add = selectTable(t1, 3);
    printf("%d\n", add);

    printf("将元素3改为6:\n");
    t1 = amendTable(t1, 3, 6);
    displayTable(t1);
    return 0;
}
~~~

程序运行结果为：

~~~shell
原顺序表：
1 2 3 4 5
删除元素1:
2 3 4 5
在第2的位置插入元素5:
2 5 3 4 5
查找元素3的位置:
3
将元素3改为6:
2 5 6 4 5
~~~



##### 2.4 链表是什么


链表，别名链式存储结构或单链表，用于存储逻辑关系为 "一对一" 的数据。与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其**物理存储位置是随机的**。

例如，使用链表存储 `{1,2,3}`，数据的物理存储状态如图1 所示：


![链表随机存储数据](http://data.biancheng.net/uploads/allimg/181123/2-1Q12321231CA.gif)

<center>图 1 链表随机存储数据</center>


我们看到，图 1 根本无法体现出各数据之间的逻辑关系。对此，链表的解决方案是，每个数据元素在存储时都配备一个指针，用于指向自己的直接后继元素。如图 2 所示：


![各数据元素配备指针](http://data.biancheng.net/uploads/allimg/181123/2-1Q12321243O36.gif)

<center>图 2 各数据元素配备指针</center>


像图 2 这样，数据元素随机存储，并通过指针表示数据之间逻辑关系的存储结构就是链式存储结构。

###### 2.4.1 链表的节点

从图 2 可以看到，链表中每个数据的存储都由以下两部分组成：

1. 数据元素本身，其所在的区域称为数据域；
2. 指向直接后继元素的指针，所在的区域称为指针域；


即链表中存储各数据元素的结构如图 3 所示：


![img](http://data.biancheng.net/uploads/allimg/181123/2-1Q1232126112G.gif)

<center>图 3 节点结构</center>


图 3 所示的结构在链表中称为节点。也就是说，链表实际存储的是一个一个的节点，真正的数据元素包含在这些节点中，如图 4 所示：


![链表中的节点](http://data.biancheng.net/uploads/allimg/181123/2-1Q123212Q3337.gif)

<center>图 4 链表中的节点</center>


因此，链表中每个节点的具体实现，需要使用 C 语言中的结构体，具体实现代码为：

```c
typedef struct Link{
    char elem; //代表数据域
    struct Link * next; //代表指针域，指向直接后继元素
}link; //link为节点名，每个节点都是一个 link 结构体
```

提示，由于指针域中的指针要指向的也是一个节点，因此要声明为 Link 类型（这里要写成 `struct Link*` 的形式）。

>指针类型是指针所指向的数据类型

###### 2.4.2 头节点，头指针和首元节点

其实，图 4 所示的链表结构并不完整。一个完整的链表需要由以下几部分构成：

1. 头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；
2. 节点：链表中的节点又细分为头节点、首元节点和其他节点：
   - 头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；
   - 首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；
   - 其他节点：链表中其他的节点；


因此，一个存储 `{1,2,3}` 的完整链表结构如图 5 所示：


![完整的链表示意图](http://data.biancheng.net/uploads/allimg/181123/2-1Q123213124343.gif)

<center>图 5 完整的链表示意图</center>

> 注意：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。

明白了链表的基本结构，下面我们来学习如何创建一个链表。

###### 2.4.3 链表的创建（初始化）

创建一个链表需要做如下工作：

1. 声明一个头指针（如果有必要，可以声明一个头节点）；
2. 创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；


例如，创建一个存储 `{1,2,3,4}` 且无头节点的链表，C 语言实现代码如下：

```c
link * initLink() {
    int i;
    link * p = NULL;//创建头指针
    link * temp = (link*)malloc(sizeof(link));//创建首元节点
    //首元节点先初始化
    temp->elem = 1;
    temp->next = NULL;
    p = temp;//头指针指向首元节点
    //从第二个节点开始创建
    for (i = 2; i < 5; i++) {
        //创建一个新节点并初始化
        link *a = (link*)malloc(sizeof(link));
        a->elem = i;
        a->next = NULL;
        //将temp节点与新建立的a节点建立逻辑关系
        temp->next = a;
        //指针temp每次都指向新链表的最后一个节点，其实就是 a节点，这里写temp=a也对
        temp = temp->next;
    }
    //返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表
    return p;
}
```

如果想创建一个存储 `{1,2,3,4}` 且含头节点的链表，则 C 语言实现代码为：

```c
link * initLink(){
    int i;
    link * p=(link*)malloc(sizeof(link));//创建一个头结点
    link * temp=p;//声明一个指针指向头结点，
    //生成链表
    for (i=1; i<5; i++) {
        link *a=(link*)malloc(sizeof(link));
        a->elem=i;
        a->next=NULL;
        temp->next=a;
        temp=temp->next;
    }
    return p;
}
```

>有无头结点在创建链表的区别
>
>有头结点 初始化 头结点 头指针  临时指针 然后生成时 利用 temp 作为中间指针 
>
>无头结点 生成 第一个结点 和 头指针

我们只需在主函数中调用 initLink 函数，即可轻松创建一个存储 `{1,2,3,4}` 的链表，C 语言完整代码如下：

```c
#include <stdio.h>
#include <stdlib.h>
//链表中节点的结构
typedef struct Link {
    int  elem;
    struct Link *next;
}link;
//初始化链表的函数
link * initLink();
//用于输出链表的函数
void display(link *p);

int main() {
    link*p = NULL;
    //初始化链表（1，2，3，4）
    printf("初始化链表为：\n");
    p = initLink();
    display(p);
    return 0;
}

link * initLink() {
    int i;
    link * p = NULL;//创建头指针
    link * temp = (link*)malloc(sizeof(link));//创建首元节点
    //首元节点先初始化
    temp->elem = 1;
    temp->next = NULL;
    p = temp;//头指针指向首元节点
    for (i = 2; i < 5; i++) {
        link *a = (link*)malloc(sizeof(link));
        a->elem = i;
        a->next = NULL;
        temp->next = a;
        temp = temp->next;
    }
    return p;
}
void display(link *p) {
    link* temp = p;//将temp指针重新指向头结点
    //只要temp指针指向的结点的next不是Null，就执行输出语句。
    while (temp) {
        printf("%d ", temp->elem);
        temp = temp->next;
    }
    printf("\n");
}
```

程序运行结果为：

```shell
初始化链表为：
1 2 3 4
```


注意，如果使用带有头节点创建链表的方式，则输出链表的 display 函数需要做适当地修改：(因为头结点elem为空)

```c
void display(link *p){
    link* temp=p;//将temp指针重新指向头结点
    //只要temp指针指向的结点的next不是Null，就执行输出语句。
    while (temp->next) {
        temp=temp->next;
        printf("%d",temp->elem);
    }
    printf("\n");
}
```

###### 2.4.4  头结点和头指针在链表中的作用

对于任意一个[链表](http://data.biancheng.net/view/160.html)来说，其构成部分无疑是：头指针、头结点和存放数据的结点这 3 类，如下[图](http://data.biancheng.net/view/200.html)所示：


![img](http://data.biancheng.net/uploads/allimg/180504/2-1P504152005N4.png)

<center>图 1 完整的链表结构</center>

- 头指针 

  头指针，是指向链表中一个结点所在存储位置的指针。如果链表中有头结点，则头指针指向头结点；若链表中没有头结点，则头指针指向链表中第一个数据结点（也叫首元结点）。

  由于使用链表存储的数据，其真实的物理存储地址并没有相互紧挨着（[数组](http://data.biancheng.net/view/181.html)的存储空间是紧挨着的），而是由系统随机分配。所以为了能够方便地找到链表中存储的数据，为链表创建头指针就显得至为重要。

  链表有头指针，当我们需要使用链表中的数据时，我们可以使用遍历查找等方法，从头指针指向的结点开始，依次搜索，直到找到需要的数据；反之，若没有头指针，则链表中的数据根本无法使用，也就失去了存储数据的意义。

  > 在计算机中，数据的存储是为了更方便地使用，一切不以使用为目向计算机中存储的数据都是垃圾数据。

- 头结点 

  头结点，位于链表的表头，即链表中第一个结点，其一般不存储任何数据，特殊情况可存储表示链表信息（表的长度等）的数据。

  头结点的存在，其本身没有任何作用，就是一个空结点，但是在对链表的某些操作中，链表有无头结点，可以直接影响编程实现的难易程度。

  例如，若链表无头结点，则对于在链表中第一个数据结点之前插入一个新结点，或者对链表中第一个数据结点做删除操作，都必须要当做特殊情况，进行特殊考虑；而若链表中设有头结点，以上两种特殊情况都可被视为普通情况，不需要特殊考虑，降低了问题实现的难度。

  链表有头结点，也不一定都是有利的。例如解决约瑟夫环问题，若链表有头结点，在一定程度上会阻碍算法的实现。

  所以，对于一个链表来说，设置头指针是必要且必须的，但有没有头结点，则需要根据实际问题特殊分析。



##### 2.5 链表的基本操作

本节将详细介绍对链表的一些基本操作，包括对链表中数据的添加、删除、查找（遍历）和更改。

注意，以下对链表的操作实现均建立在已创建好链表的基础上，创建链表的代码如下所示：

```c
//声明节点结构
typedef struct Link {
    int  elem;//存储整形元素
    struct Link *next;//指向直接后继元素的指针
}link;
//创建链表的函数
link * initLink() {
    link * p = (link*)malloc(sizeof(link));//创建一个头结点
    link * temp = p;//声明一个指针指向头结点，用于遍历链表
    int i = 0;
    //生成链表
    for (i = 1; i < 5; i++) {
        //创建节点并初始化
        link *a = (link*)malloc(sizeof(link));
        a->elem = i;
        a->next = NULL;
        //建立新节点与直接前驱节点的逻辑关系
        temp->next = a;
        temp = temp->next;
    }
    return p;
}
```

从实现代码中可以看到，该链表是一个具有头节点的链表。由于头节点本身不用于存储数据，因此在实现对链表中数据的"增删查改"时要引起注意。

###### 2.5.1 链表插入元素

同顺序表一样，向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：

- 插入到链表的头部（头节点之后），作为首元节点；
- 插入到链表中间的某个位置；
- 插入到链表的最末端，作为链表中最后一个数据元素；


虽然新元素的插入位置不固定，但是链表插入元素的思想是固定的，只需做以下两步操作，即可将新元素插入到指定的位置：

1. 将新结点的 next 指针指向插入位置后的结点；
2. 将插入位置前结点的 next 指针指向插入结点；


例如，我们在链表 `{1,2,3,4}` 的基础上分别实现在头部、中间部位、尾部插入新元素 5，其实现过程如图 1 所示：


![链表中插入元素的 3 种情况示意图](http://data.biancheng.net/uploads/allimg/181124/2-1Q1242005532U.gif)

<center>图 1 链表中插入元素的 3 种情况示意图</center>


从图中可以看出，虽然新元素的插入位置不同，但实现插入操作的方法是一致的，都是先执行步骤 1 ，再执行步骤 2。

注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，会导致插入位置后续的部分链表丢失，无法再实现步骤 1。

通过以上的讲解，我们可以尝试编写 C 语言代码来实现链表插入元素的操作：

```c
//p为原链表，elem表示新数据元素，add表示新元素要插入的位置
link * insertElem(link * p, int elem, int add) {
    link * temp = p;//创建临时结点temp
    link * c = NULL;
    int i = 0;
    //首先找到要插入位置的上一个结点
    for (i = 1; i < add; i++) {
        if (temp == NULL) {
            printf("插入位置无效\n");
            return p;
        }
        temp = temp->next;
    }
    //创建插入结点c
    c = (link*)malloc(sizeof(link));
    c->elem = elem;
    //向链表中插入结点
    c->next = temp->next;
    temp->next = c;
    return  p;
}
```

提示，insertElem 函数中加入一个 if 语句，用于判断用户输入的插入位置是否有效。例如，在已存储 `{1,2,3}` 的链表中，用户要求在链表中第 100 个数据元素所在的位置插入新元素，显然用户操作无效，此时就会触发 if 语句。

###### 2.5.2 链表删除元素

从链表中删除指定数据元素时，实则就是将存有该数据元素的节点从链表中摘除，但作为一名合格的程序员，要对存储空间负责，对不再利用的存储空间要及时释放。因此，从链表中删除数据元素需要进行以下 2 步操作：

1. 将结点从链表中摘下来;
2. 手动释放掉结点，回收被结点占用的存储空间;


其中，从链表上摘除某节点的实现非常简单，只需找到该节点的直接前驱节点 temp，执行一行程序：

```c
temp->next=temp->next->next;
```

例如，从存有 `{1,2,3,4}` 的链表中删除元素 3，则此代码的执行效果如图 2 所示：


![链表删除元素示意图](http://data.biancheng.net/uploads/allimg/181124/2-1Q124200Q3239.gif)

<center>图 2 链表删除元素示意图</center>


因此，链表删除元素的 C 语言实现如下所示：

```c
//p为原链表，add为要删除元素的值
link * delElem(link * p, int add) {
    link * temp = p;
    link * del = NULL;
    int i = 0;
    //temp指向被删除结点的上一个结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
    }
    del = temp->next;//单独设置一个指针指向被删除结点，以防丢失
    temp->next = temp->next->next;//删除某个结点的方法就是更改前一个结点的指针域
    free(del);//手动释放该结点，防止内存泄漏
    return p;
}
```

我们可以看到，从链表上摘下的节点 del 最终通过 free 函数进行了手动释放。

###### 2.5.3 链表查找元素

在链表中查找指定数据元素，最常用的方法是：从表头依次遍历表中节点，用被查找元素与各节点数据域中存储的数据元素进行比对，直至比对成功或遍历至链表最末端的 `NULL`（比对失败的标志）。

因此，链表中查找特定数据元素的 C 语言实现代码为：

```c
//p为原链表，elem表示被查找元素、
int selectElem(link * p, int elem) {
    //新建一个指针t，初始化为头指针 p
    link * t = p;
    int i = 1;
    //由于头节点的存在，因此while中的判断为t->next
    while (t->next) {
        t = t->next;
        if (t->elem == elem) {
            return i;
        }
        i++;
    }
    //程序执行至此处，表示查找失败
    return -1;
}
```

注意，遍历有头节点的链表时，需避免头节点对测试数据的影响，因此在遍历链表时，建立使用上面代码中的遍历方法，直接越过头节点对链表进行有效遍历。

###### 2.5.4 链表更新元素

更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。

直接给出链表中更新数据元素的 C 语言实现代码：

```c
//更新函数，其中，add 表示更改结点在链表中的位置，newElem 为新的数据域的值
link *amendElem(link * p, int add, int newElem) {
    int i = 0;
    link * temp = p;
    temp = temp->next;//在遍历之前，temp指向首元结点
    //遍历到被删除结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
    }
    temp->elem = newElem;
    return p;
}
```

###### 2.5.5 总结

以上内容详细介绍了对链表中数据元素做"增删查改"的实现过程及 C 语言代码，在此给出本节的完整可运行代码：

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Link {
    int  elem;
    struct Link *next;
}link;
link * initLink();
//链表插入的函数，p是链表，elem是插入的结点的数据域，add是插入的位置
link * insertElem(link * p, int elem, int add);
//删除结点的函数，p代表操作链表，add代表删除节点的位置
link * delElem(link * p, int add);
//查找结点的函数，elem为目标结点的数据域的值
int selectElem(link * p, int elem);
//更新结点的函数，newElem为新的数据域的值
link *amendElem(link * p, int add, int newElem);
void display(link *p);

int main() {
    link *p = NULL;
    int address;
    //初始化链表（1，2，3，4）
    printf("初始化链表为：\n");
    p = initLink();
    display(p);

    printf("在第4的位置插入元素5：\n");
    p = insertElem(p, 5, 4);
    display(p);

    printf("删除元素3:\n");
    p = delElem(p, 3);
    display(p);

    printf("查找元素2的位置为：\n");
    address = selectElem(p, 2);
    if (address == -1) {
        printf("没有该元素");
    }
    else {
        printf("元素2的位置为：%d\n", address);
    }
    printf("更改第3的位置上的数据为7:\n");
    p = amendElem(p, 3, 7);
    display(p);

    return 0;
}

link * initLink() {
    link * p = (link*)malloc(sizeof(link));//创建一个头结点
    link * temp = p;//声明一个指针指向头结点，用于遍历链表
    int i = 0;
    //生成链表
    for (i = 1; i < 5; i++) {
        link *a = (link*)malloc(sizeof(link));
        a->elem = i;
        a->next = NULL;
        temp->next = a;
        temp = temp->next;
    }
    return p;
}
link * insertElem(link * p, int elem, int add) {
    link * temp = p;//创建临时结点temp
    link * c = NULL;
    int i = 0;
    //首先找到要插入位置的上一个结点
    for (i = 1; i < add; i++) {
        if (temp == NULL) {
            printf("插入位置无效\n");
            return p;
        }
        temp = temp->next;
    }
    //创建插入结点c
    c = (link*)malloc(sizeof(link));
    c->elem = elem;
    //向链表中插入结点
    c->next = temp->next;
    temp->next = c;
    return  p;
}

link * delElem(link * p, int add) {
    link * temp = p;
    link * del = NULL;
    int i = 0;
    //遍历到被删除结点的上一个结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
    }
    del = temp->next;//单独设置一个指针指向被删除结点，以防丢失
    temp->next = temp->next->next;//删除某个结点的方法就是更改前一个结点的指针域
    free(del);//手动释放该结点，防止内存泄漏
    return p;
}
int selectElem(link * p, int elem) {
    link * t = p;
    int i = 1;
    while (t->next) {
        t = t->next;
        if (t->elem == elem) {
            return i;
        }
        i++;
    }
    return -1;
}
link *amendElem(link * p, int add, int newElem) {
    int i = 0;
    link * temp = p;
    temp = temp->next;//tamp指向首元结点
    //temp指向被删除结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
    }
    temp->elem = newElem;
    return p;
}
void display(link *p) {
    link* temp = p;//将temp指针重新指向头结点
    //只要temp指针指向的结点的next不是Null，就执行输出语句。
    while (temp->next) {
        temp = temp->next;
        printf("%d ", temp->elem);
    }
    printf("\n");
}
```

代码运行结果：

```
初始化链表为：
1 2 3 4
在第4的位置插入元素5：
1 2 3 5 4
删除元素3:
1 2 5 4
查找元素2的位置为：
元素2的位置为：2
更改第3的位置上的数据为7:
1 2 7 4
```



##### 2.6 顺序表和链表的优缺点(区别、特点)详解

顺序表和链表由于存储结构上的差异，导致它们具有不同的特点，适用于不同的场景。本节就来分析它们的特点，让读者明白 "在什么样的场景中使用哪种存储结构" 更能有效解决问题。

通过系统地学习顺序表和链表我们知道，虽然它们同属于线性表，但数据的存储结构有本质的不同：

- 顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据之间紧密贴合，不留一丝空隙，如图 1a) 所示；
- 链表的存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持，如图 1b) 所示；

![顺序表和链表的存储结构对比](http://data.biancheng.net/uploads/allimg/181125/2-1Q12512244c10.gif)

<center>图 1 顺序表和链表的存储结构对比</center>


基于不同的存储结构，顺序表和链表有以下几种不同。

###### 2.6.1 开辟空间的方式

顺序表存储数据实行的是 "一次开辟，永久使用"，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。

而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。

因此，若只从开辟空间方式的角度去考虑，当存储数据的个数无法提前确定，又或是物理空间使用紧张以致无法一次性申请到足够大小的空间时，使用链表更有助于问题的解决。

###### 2.6.2 空间利用率

从空间利用率的角度上看，顺序表的空间利用率显然要比链表高。

这是因为，链表在存储数据时，每次只申请一个节点的空间，且空间的位置是随机的，如图 2 所示：


![链表结构易产生碎片](http://data.biancheng.net/uploads/allimg/181125/2-1Q12512255D10.gif)

<center>图 2 链表结构易产生碎片</center>


这种申请存储空间的方式会产生很多空间碎片，一定程序上造成了空间浪费。不仅如此，由于链表中每个数据元素都必须携带至少一个指针，因此，链表对所申请空间的利用率也没有顺序表高。

> 空间碎片，指的是某些容量很小（1KB 甚至更小）以致无法得到有效利用的物理空间。

###### 2.6.3 时间复杂度

解决不同类型的问题，顺序表和链表对应的时间复杂度也不同。

根据顺序表和链表在存储结构上的差异，问题类型主要分为以下 2 类：

1. 问题中主要涉及访问元素的操作，元素的插入、删除和移动操作极少；
2. 问题中主要涉及元素的插入、删除和移动，访问元素的需求很少；


第 1 类问题适合使用顺序表。这是因为，顺序表中存储的元素可以使用数组下标直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为 `O(1)`；而在链表中访问数据元素，需要从表头依次遍历，直到找到指定节点，花费的时间复杂度为 `O(n)`;

第 2 类问题则适合使用链表。链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动元素，因此链表中插入、删除或移动数据所耗费的时间复杂度为 `O(1)`；而顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，因此时间复杂度至少为 `O(n)`;

综上所述，不同类型的场景，选择合适的存储结构会使解决问题效率成倍数地提高。



##### 2.7 双向链表 及其创建

目前我们所学到的链表，无论是动态链表还是[静态链表](http://data.biancheng.net/view/163.html)，表中各节点中都只包含一个指针（游标），且都统一指向直接后继节点，通常称这类链表为单向链表（或单链表）。

虽然使用单链表能 100% 解决逻辑关系为 "一对一" 数据的存储问题，但在解决某些特殊问题时，单链表并不是效率最优的存储结构。比如说，某场景中需要大量地查找某结点的前趋结点，这种情况下使用单链表无疑是灾难性的，因为单链表更适合 "从前往后" 找，"从后往前" 找并不是它的强项。

对于逆向查找（从后往前）相关的问题，使用本节讲解的双向链表，会更加事半功倍。

双向链表，简称双链表。从名字上理解双向链表，即链表是 "双向" 的，如图 1 所示：


![双向链表结构示意图](http://data.biancheng.net/uploads/allimg/181128/2-1Q12R01Q63Q.gif)

<center>图 1 双向链表结构示意图</center>

所谓双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要，可以为最后一个节点再设置一个“头指针”。

根据图 1 不难看出，双向链表中各节点包含以下 3 部分信息（如图 2 所示）：

1. 指针域：用于指向当前节点的直接前驱节点；
2. 数据域：用于存储数据元素；
3. 指针域：用于指向当前节点的直接后继节点。


![双向链表的节点构成](http://data.biancheng.net/uploads/allimg/181128/2-1Q12R01910615.gif)

<center>图 2 双向链表的节点构成</center>


因此，双链表的节点结构用 C 语言实现为：

```c
typedef struct line{
    struct line * prior; //指向直接前趋
    int data;
    struct line * next; //指向直接后继
}line;
```

> 读者可根据实际场景的需要，调整数据域 data 的数据类型。

###### 2.7.1 双向链表的创建

同单链表相比，双链表仅是各节点多了一个用于指向直接前驱的指针域。因此，我们可以在单链表的基础轻松实现对双链表的创建。

和创建单链表不同的是，创建双向链表的过程中，每一个新节点都要和前驱节点之间建立两次链接，分别是：

- 将新节点的 prior 指针指向直接前驱节点；
- 将直接前驱节点的 next 指针指向新节点；


这里给出创建双向链表的 C 语言实现代码：

```c
line* initLine(line * head) {
    int i = 0;
    line * list = NULL;
    //创建一个首元节点，链表的头指针为head
    head = (line*)malloc(sizeof(line));
    //对节点进行初始化
    head->prior = NULL;
    head->next = NULL;
    head->data = 1;
    //声明一个指向首元节点的指针，方便后期向链表中添加新创建的节点
    list = head;
    for (i = 2; i <= 5; i++) {
        //创建新的节点并初始化
        line * body = (line*)malloc(sizeof(line));
        body->prior = NULL;
        body->next = NULL;
        body->data = i;

        //新节点与链表最后一个节点建立关系
        list->next = body;
        body->prior = list;
        //list永远指向链表中最后一个节点
        list = list->next;
    }
    //返回新创建的链表
    return head;
}
```


我们可以尝试着在 main 函数中输出创建的双链表，C 语言代码如下：

```c
#include <stdio.h>
#include <stdlib.h>
//节点结构
typedef struct line {
    struct line * prior;
    int data;
    struct line * next;
}line;
//双链表的创建函数
line* initLine(line * head);
//输出双链表的函数
void display(line * head);

int main() {
    //创建一个头指针
    line * head = NULL;
    //调用链表创建函数
    head = initLine(head);
    //输出创建好的链表
    display(head);
    //显示双链表的优点
    printf("链表中第 4 个节点的直接前驱是：%d", head->next->next->next->prior->data);
    return 0;
}
line* initLine(line * head) {
    int i = 0;
    line * list = NULL;
    //创建一个首元节点，链表的头指针为head
    head = (line*)malloc(sizeof(line));
    //对节点进行初始化
    head->prior = NULL;
    head->next = NULL;
    head->data = 1;
    //声明一个指向首元节点的指针，方便后期向链表中添加新创建的节点
    list = head;
    for (i = 2; i <= 5; i++) {
        //创建新的节点并初始化
        line * body = (line*)malloc(sizeof(line));
        body->prior = NULL;
        body->next = NULL;
        body->data = i;

        //新节点与链表最后一个节点建立关系
        list->next = body;
        body->prior = list;
        //list永远指向链表中最后一个节点
        list = list->next;
    }
    //返回新创建的链表
    return head;
}
void display(line * head) {
    line * temp = head;
    while (temp) {
        //如果该节点无后继节点，说明此节点是链表的最后一个节点
        if (temp->next == NULL) {
            printf("%d\n", temp->data);
        }
        else {
            printf("%d <-> ", temp->data);
        }
        temp = temp->next;
    }
}
```

程序运行结果：

```shell
1 <-> 2 <-> 3 <-> 4 <-> 5
链表中第 4 个节点的直接前驱是：3
```



##### 2.8 双向链表的基本操作

本节知识基于已熟练掌握双向链表创建过程的基础上，我们继续上节所创建的双向链表来学习本节内容，创建好的双向链表如图 1 所示：


![双向链表示意图](http://data.biancheng.net/uploads/allimg/181129/2-1Q12ZQIWK.gif)

<center>图 1 双向链表示意图</center>

###### 2.8.1 双向链表添加节点

根据数据添加到双向链表中的位置不同，可细分为以下 3 种情况：

一 添加至表头

将新数据元素添加到表头，只需要将该元素与表头元素建立双层逻辑关系即可。

换句话说，假设新元素节点为 temp，表头节点为 head，则需要做以下 2 步操作即可：

1. temp->next=head; head->prior=temp;
2. 将 head 移至 temp，重新指向新的表头；


例如，将新元素 7 添加至双链表的表头，则实现过程如图 2 所示：


![添加元素至双向链表的表头](http://data.biancheng.net/uploads/allimg/181129/2-1Q12ZQT5263.gif)

<center>图 2 添加元素至双向链表的表头</center>

二  添加至表的中间位置

同单链表添加数据类似，双向链表中间位置添加数据需要经过以下 2 个步骤，如图 3 所示：

1. 新节点先与其直接后继节点建立双层逻辑关系；
2. 新节点的直接前驱节点与之建立双层逻辑关系；


![双向链表中间位置添加数据元素](http://data.biancheng.net/uploads/allimg/181129/2-1Q12ZQ915562.gif)

<center>图 3 双向链表中间位置添加数据元素</center>

三  添加至表尾

与添加到表头是一个道理，实现过程如下（如图 4 所示）：

1. 找到双链表中最后一个节点；
2. 让新节点与最后一个节点进行双层逻辑关系；


![双向链表尾部添加数据元素](http://data.biancheng.net/uploads/allimg/181129/2-1Q12ZR0305L.gif)

<center>图 4 双向链表尾部添加数据元素</center>


因此，我们可以试着编写双向链表添加数据的 C 语言代码，参考代码如下：

```c
//data 为要添加的新数据，add 为添加到链表中的位置
line * insertLine(line * head, int data, int add) {
    //新建数据域为data的结点
    line * temp = (line*)malloc(sizeof(line));
    temp->data = data;
    temp->prior = NULL;
    temp->next = NULL;
    //插入到链表头，要特殊考虑
    if (add == 1) {
        temp->next = head;
        head->prior = temp;
        head = temp;
    }
    else {
        int i = 0;
        line * body = head;
        //找到要插入位置的前一个结点
        for (i = 1; i < add - 1; i++) {
            body = body->next;
            if (body == NULL) {
                printf("插入位置有误\n");
                break;
            }
        }
        if (body) {
            //判断条件为真，说明插入位置为链表尾
            if (body->next == NULL) {
                body->next = temp;
                temp->prior = body;
            }
            else {
                body->next->prior = temp;
                temp->next = body->next;
                body->next = temp;
                temp->prior = body;
            }
        }
    }
    return head;
}
```

###### 2.8.2 双向链表删除节点

双链表删除结点时，只需遍历链表找到要删除的结点，然后将该节点从表中摘除即可。

例如，从图 1 基础上删除元素 2 的操作过程如图 5 所示：



![双链表删除元素操作示意图](http://data.biancheng.net/uploads/allimg/181129/2-1Q12ZR10D13.gif)

<center>图 5 双链表删除元素操作示意图</center>


双向链表删除节点的 C 语言实现代码如下：

```c
//删除结点的函数，data为要删除结点的数据域的值
line * delLine(line * head, int data) {
    line * temp = head;
    //遍历链表
    while (temp) {
        //判断当前结点中数据域和data是否相等，若相等，摘除该结点
        if (temp->data == data) {
            temp->prior->next = temp->next;
            temp->next->prior = temp->prior;
            free(temp);
            return head;
        }
        temp = temp->next;
    }
    printf("链表中无该数据元素\n");
    return head;
}
```

###### 2.8.3 双向链表查找节点

通常，双向链表同单链表一样，都仅有一个头指针。因此，双链表查找指定元素的实现同单链表类似，都是从表头依次遍历表中元素。

C 语言实现代码为：

```c
//head为原双链表，elem表示被查找元素
int selectElem(line * head, int elem) {
    //新建一个指针t，初始化为头指针 head
    line * t = head;
    int i = 1;
    while (t) {
        if (t->data == elem) {
            return i;
        }
        i++;
        t = t->next;
    }
    //程序执行至此处，表示查找失败
    return -1;
}
```

###### 2.8.4 双向链表更改节点

更改双链表中指定结点数据域的操作是在查找的基础上完成的。实现过程是：通过遍历找到存储有该数据元素的结点，直接更改其数据域即可。

实现此操作的 C 语言实现代码如下：

```c
//更新函数，其中，add 表示更改结点在双链表中的位置，newElem 为新数据的值
line *amendElem(line * p, int add, int newElem) {
    int i = 0;
    line * temp = p;
    //遍历到被删除结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
        if (temp == NULL) {
            printf("更改位置有误！\n");
            break;
        }
    }
    if (temp) {
        temp->data = newElem;
    }
    return p;
}
```

###### 2.8.5 总结

这里给出双链表中对数据进行 "增删查改" 操作的完整实现代码：

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct line {
    struct line * prior;
    int data;
    struct line * next;
}line;
//双链表的创建
line* initLine(line * head);
//双链表插入元素，add表示插入位置
line * insertLine(line * head, int data, int add);
//双链表删除指定元素
line * delLine(line * head, int data);
//双链表中查找指定元素
int selectElem(line * head, int elem);
//双链表中更改指定位置节点中存储的数据，add表示更改位置
line *amendElem(line * p, int add, int newElem);
//输出双链表的实现函数
void display(line * head);
int main() {
    line * head = NULL;
    //创建双链表
    printf("初始链表为：\n");
    head = initLine(head);
    display(head);
    //在表中第 3 的位置插入元素 7
    printf("在表中第 3 的位置插入新元素 7：\n");
    head = insertLine(head, 7, 3);
    display(head);
    //表中删除元素 2
    printf("删除元素 2：\n");
    head = delLine(head, 2);
    display(head);

    printf("元素 3 的位置是：%d\n", selectElem(head, 3));
    //表中第 3 个节点中的数据改为存储 6
    printf("将第 3 个节点存储的数据改为 6：\n");
    head = amendElem(head, 3, 6);
    display(head);
    return 0;
}
line* initLine(line * head) {
    int i = 0;
    line * list = NULL;
    head = (line*)malloc(sizeof(line));
    head->prior = NULL;
    head->next = NULL;
    head->data = 1;
    list = head;
    for (i = 2; i <= 3; i++) {
        line * body = (line*)malloc(sizeof(line));
        body->prior = NULL;
        body->next = NULL;
        body->data = i;

        list->next = body;
        body->prior = list;
        list = list->next;
    }
    return head;
}
line * insertLine(line * head, int data, int add) {
    //新建数据域为data的结点
    line * temp = (line*)malloc(sizeof(line));
    temp->data = data;
    temp->prior = NULL;
    temp->next = NULL;
    //插入到链表头，要特殊考虑
    if (add == 1) {
        temp->next = head;
        head->prior = temp;
        head = temp;
    }
    else {
        int i = 0;
        line * body = head;
        //找到要插入位置的前一个结点
        for (i = 1; i < add - 1; i++) {
            body = body->next;
            if (body == NULL) {
                printf("插入位置有误\n");
                break;
            }
        }
        if (body) {
            //判断条件为真，说明插入位置为链表尾
            if (body->next == NULL) {
                body->next = temp;
                temp->prior = body;
            }
            else {
                body->next->prior = temp;
                temp->next = body->next;
                body->next = temp;
                temp->prior = body;
            }
        }
    }
    return head;
}
line * delLine(line * head, int data) {
    line * temp = head;
    //遍历链表
    while (temp) {
        //判断当前结点中数据域和data是否相等，若相等，摘除该结点
        if (temp->data == data) {
            temp->prior->next = temp->next;
            temp->next->prior = temp->prior;
            free(temp);
            return head;
        }
        temp = temp->next;
    }
    printf("链表中无该数据元素\n");
    return head;
}
//head为原双链表，elem表示被查找元素
int selectElem(line * head, int elem) {
    //新建一个指针t，初始化为头指针 head
    line * t = head;
    int i = 1;
    while (t) {
        if (t->data == elem) {
            return i;
        }
        i++;
        t = t->next;
    }
    //程序执行至此处，表示查找失败
    return -1;
}
//更新函数，其中，add 表示更改结点在双链表中的位置，newElem 为新数据的值
line *amendElem(line * p, int add, int newElem) {
    int i = 0;
    line * temp = p;
    //遍历到被删除结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
        if (temp == NULL) {
            printf("更改位置有误！\n");
            break;
        }
    }
    if (temp) {
        temp->data = newElem;
    }
    return p;
}
//输出链表的功能函数
void display(line * head) {
    line * temp = head;
    while (temp) {
        if (temp->next == NULL) {
            printf("%d\n", temp->data);
        }
        else {
            printf("%d->", temp->data);
        }
        temp = temp->next;
    }
}
```

程序执行结果为：

```
初始链表为：
1->2->3
在表中第 3 的位置插入新元素 7：
1->2->7->3
删除元素 2：
1->7->3
元素 3 的位置是：3
将第 3 个节点存储的数据改为 6：
1->7->6
```



#### 三 栈和队列

##### 3.1 什么是栈

同顺序表和链表

一样，栈也是用来存储逻辑关系为 "一对一" 数据的线性存储结构，如图 1 所示。


![栈存储结构示意图](http://data.biancheng.net/uploads/allimg/181201/2-1Q201203Q5110.gif)

<center>图 1 栈存储结构示意图</center>


从图 1 我们看到，栈存储结构与之前所学的线性存储结构有所差异，这缘于栈对数据 "存" 和 "取" 的过程有特殊的要求：

1. 栈只能从表的一端存取数据，另一端是封闭的，如图 1 所示；
2. 在栈中，无论是存数据还是取数据，都必须遵循"先进后出"的原则，即最先进栈的元素最后出栈。拿图 1 的栈来说，从图中数据的存储状态可判断出，元素 1 是最先进的栈。因此，当需要从栈中取出元素 1 时，根据"先进后出"的原则，需提前将元素 3 和元素 2 从栈中取出，然后才能成功取出元素 1。

因此，我们可以给栈下一个定义，即

> 栈是一种只能从表的一端存取数据且遵循 "先进后出" 原则的线性存储结构。

**栈顶元素**：

通常，栈的开口端被称为栈顶；相应地，封口端被称为栈底。因此，栈顶元素指的就是距离栈顶最近的元素，拿图 2 来说，栈顶元素为元素 4；同理，栈底元素指的是位于栈最底部的元素，图 2 中的栈底元素为元素 1。


![栈顶和栈底](http://data.biancheng.net/uploads/allimg/181201/2-1Q201204153P8.gif)

<center>图 2 栈顶和栈底</center>

###### 3.1.1 进栈和出栈

基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：

- 向栈中添加元素，此过程被称为"进栈"（入栈或压栈）；
- 从栈中提取出指定元素，此过程被称为"出栈"（或弹栈）；

###### 3.1.2 栈的具体实现

栈是一种 "特殊" 的线性存储结构，因此栈的具体实现有以下两种方式：

1. [顺序栈](http://data.biancheng.net/view/170.html)：采用顺序存储结构可以模拟栈存储数据的特点，从而实现栈存储结构；
2. [链栈](http://data.biancheng.net/view/171.html)：采用链式存储结构实现栈结构；

两种实现方式的区别，仅限于数据元素在实际物理空间上存放的相对位置，顺序栈底层采用的是数组，链栈底层采用的是链表。有关顺序栈和链栈的具体实现会在后续章节中作详细讲解。

###### 3.1.3 栈的应用

基于栈结构对数据存取采用 "先进后出" 原则的特点，它可以用于实现很多功能。

例如，我们经常使用浏览器在各种网站上查找信息。假设先浏览的页面 A，然后关闭了页面 A 跳转到页面 B，随后又关闭页面 B 跳转到了页面 C。而此时，我们如果想重新回到页面 A，有两个选择：

- 重新搜索找到页面 A；
- 使用浏览器的"回退"功能。浏览器会先回退到页面 B，而后再回退到页面 A。


浏览器 "回退" 功能的实现，底层使用的就是栈存储结构。当你关闭页面 A 时，浏览器会将页面 A 入栈；同样，当你关闭页面 B 时，浏览器也会将 B入栈。因此，当你执行回退操作时，才会首先看到的是页面 B，然后是页面 A，这是栈中数据依次出栈的效果。

不仅如此，栈存储结构还可以帮我们检测代码中的[括号匹配](http://data.biancheng.net/view/87.html)问题。多数编程语言都会用到括号（小括号、中括号和大括号），括号的错误使用（通常是丢右括号）会导致程序编译错误，而很多开发工具中都有检测代码是否有编辑错误的功能，其中就包含检测代码中的括号匹配问题，此功能的底层实现使用的就是栈结构。

同时，栈结构还可以实现数值的[进制转换](http://data.biancheng.net/view/86.html)功能。例如，编写程序实现从十进制数自动转换成二进制数，就可以使用栈存储结构来实现。

以上也仅是栈应用领域的冰山一角，这里不再过多举例。在后续章节的学习中，我们会大量使用到栈结构。

接下来，我们学习如何实现顺序栈和链栈，以及对栈中元素进行入栈和出栈的操作。



##### 3.2 顺序栈的基本操作 

顺序栈，即用顺序表实现栈存储结构。通过前面的学习我们知道，使用栈存储结构操作数据元素必须遵守 "先进后出" 的原则，本节就 "如何使用顺序表模拟栈以及实现对栈中数据的基本操作（出栈和入栈）" 给大家做详细介绍。

如果你仔细观察顺序表（底层实现是数组](http://data.biancheng.net/view/181.html)）和栈结构就会发现，它们存储数据的方式高度相似，只不过栈对数据的存取过程有特殊的限制，而顺序表没有。

例如，我们先使用顺序表（a 数组）存储 `{1,2,3,4}`，存储状态如图1 所示：


![顺序表存储 {1,2,3,4}](http://data.biancheng.net/uploads/allimg/181202/2-1Q202131155H8.gif)

<center>图 1 顺序表存储 {1,2,3,4}</center>


同样，使用栈存储结构存储 `{1,2,3,4}`，其存储状态如图 2 所示：


![栈结构存储 {1,2,3,4}](http://data.biancheng.net/uploads/allimg/181202/2-1Q202131233249.gif)

<center>图 2 栈结构存储 {1,2,3,4}</center>


通过图 1 和图 2 的对比不难看出，使用顺序表模拟栈结构很简单，只需要将数据从 a 数组下标为 0 的位置依次存储即可。

从数组下标为 0 的模拟栈存储数据是常用的方法，从其他数组下标处存储数据也完全可以，这里只是为了方便初学者理解。

了解了顺序表模拟栈存储数据后，接下来看如何模拟栈中元素出栈的操作。由于栈对存储元素出栈的次序有"先进后出"的要求，如果想将图 1 中存储的元素 1 从栈中取出，需先将元素 4、元素 3 和元素 2 依次从栈中取出。

这里给出使用顺序表模拟栈存储结构常用的实现思路，即在顺序表中设定一个实时指向栈顶元素的变量（一般命名为 top），top 初始值为 -1，表示栈中没有存储任何数据元素，及栈是"空栈"。一旦有数据元素进栈，则 top 就做 +1 操作；反之，如果数据元素出栈，top 就做 -1 操作。

###### 3.2.1 顺序栈元素"入栈"

比如，还是模拟栈存储 `{1,2,3,4}` 的过程。最初，栈是"空栈"，即数组是空的，top 值为初始值 -1，如图 3 所示：


![空栈示意图](http://data.biancheng.net/uploads/allimg/181202/2-1Q202131603419.gif)

<center>图 3 空栈示意图</center>


首先向栈中添加元素 1，我们默认数组下标为 0 一端表示栈底，因此，元素 1 被存储在数组 a[1] 处，同时 top 值 +1，如图 4 所示：


![模拟栈存储元素 1](http://data.biancheng.net/uploads/allimg/181202/2-1Q2021316322O.gif)

<center>图 4 模拟栈存储元素 1</center>


采用以上的方式，依次存储元素 2、3 和 4，最终，top 值变为 3，如图 5 所示：


![模拟栈存储{1,2,3,4}](http://data.biancheng.net/uploads/allimg/181202/2-1Q202131649636.gif)

<center>图 5 模拟栈存储{1,2,3,4}</center>


因此，C 语言实现代码为：

```c
//元素elem进栈，a为数组，top值为当前栈的栈顶位置
int push(int* a,int top,int elem){
    a[++top]=elem;
    return top;
}
```

代码中的 a[++top]=elem，等价于先执行 ++top，再执行 a[top]=elem。

###### 3.2.2 顺序栈元素"出栈"

其实，top 变量的设置对模拟数据的 "入栈" 操作没有实际的帮助，它是为实现数据的 "出栈" 操作做准备的。

比如，将图 5 中的元素 2 出栈，则需要先将元素 4 和元素 3 依次出栈。需要注意的是，当有数据出栈时，要将 top 做 -1 操作。因此，元素 4 和元素 3 出栈的过程分别如图 6a) 和 6b) 所示：


![数据元素出栈](http://data.biancheng.net/uploads/allimg/181225/2-1Q225200HMC.gif)

<center>图 6 数据元素出栈</center>

注意，图 6 数组中元素的消失仅是为了方便初学者学习，其实，这里只需要对 top 值做 -1 操作即可，因为 top 值本身就表示栈的栈顶位置，因此 top-1 就等同于栈顶元素出栈。并且后期向栈中添加元素时，新元素会存储在类似元素 4 这样的旧元素位置上，将旧元素覆盖。

元素 4 和元素 3 全部出栈后，元素 2 才能出栈。因此，使用顺序表模拟数据出栈操作的 C 语言实现代码为：

```c
//数据元素出栈
int pop(int * a,int top){
    if (top==-1) {
        printf("空栈");
        return -1;
    }
    printf("弹栈元素：%d\n",a[top]);
    top--;
    return top;
}
```

代码中的 if 语句是为了防止用户做 "栈中已无数据却还要数据出栈" 的错误操作。代码中，关于对栈中元素出栈操作的实现，只需要 top 值 -1 即可。

###### 3.2.3 总结

通过学习顺序表模拟栈中数据入栈和出栈的操作，初学者完成了对顺序栈的学习，这里给出顺序栈及对数据基本操作的 C 语言完整代码：

```c
#include <stdio.h>
//元素elem进栈
int push(int* a,int top,int elem){
    a[++top]=elem;
    return top;
}
//数据元素出栈
int pop(int * a,int top){
    if (top==-1) {
        printf("空栈");
        return -1;
    }
    printf("弹栈元素：%d\n",a[top]);
    top--;
    return top;
}
int main() {
    int a[100];
    int top=-1;
    top=push(a, top, 1);
    top=push(a, top, 2);
    top=push(a, top, 3);
    top=push(a, top, 4);
    top=pop(a, top);
    top=pop(a, top);
    top=pop(a, top);
    top=pop(a, top);
    top=pop(a, top);
    return 0;
}
```

程序输出结果为：

```shell
弹栈元素：4
弹栈元素：3
弹栈元素：2
弹栈元素：1
空栈
```

##### 3.3  链栈的基本操作(入栈和出栈)

链栈，即用链表实现栈存储结构。

链栈的实现思路同[顺序栈](http://data.biancheng.net/view/170.html)类似，顺序栈是将数顺序表（数组）的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底，如图 1 所示：


![链栈示意图](http://data.biancheng.net/uploads/allimg/181202/2-1Q2021G31YC.gif)

<center>图 1 链栈示意图</center>

> 将链表头部作为栈顶的一端，可以避免在实现数据 "入栈" 和 "出栈" 操作时做大量遍历链表的耗时操作。

链表的头部作为栈顶，意味着：

- 在实现数据"入栈"操作时，需要将数据从链表的头部插入；
- 在实现数据"出栈"操作时，需要删除链表头部的首元节点；


**因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表。**

###### 3.3.1 链栈元素入栈

例如，将元素 1、2、3、4 依次入栈，等价于将各元素采用头插法依次添加到链表中，每个数据元素的添加过程如图 2 所示：


![链栈元素依次入栈过程示意图](http://data.biancheng.net/uploads/allimg/181202/2-1Q2021G402604.gif)

<center>图 2 链栈元素依次入栈过程示意图</center>


C语言实现代码为：

```c
//链表中的节点结构
typedef struct lineStack{
    int data;
    struct lineStack * next;
}lineStack;
//stack为当前的链栈，a表示入栈元素
lineStack* push(lineStack * stack,int a){
    //创建存储新元素的节点
    lineStack * line=(lineStack*)malloc(sizeof(lineStack));
    line->data=a;
    //新节点与头节点建立逻辑关系
    line->next=stack;
    //更新头指针的指向
    stack=line;
    return stack;
}
```

stack 是指针 还是 只想元素的结点

###### 3.3.2  链栈元素出栈

例如，图 2e) 所示的链栈中，若要将元素 3 出栈，根据"先进后出"的原则，要先将元素 4 出栈，也就是从链表中摘除，然后元素 3 才能出栈，整个操作过程如图 3 所示：


![链栈元素出栈示意图](http://data.biancheng.net/uploads/allimg/181202/2-1Q2021G432217.gif)

<center>图 3 链栈元素出栈示意图</center> 


因此，实现栈顶元素出链栈的 C 语言实现代码为：

```c
//栈顶元素出链栈的实现函数
lineStack * pop(lineStack * stack){
    if (stack) {
        //声明一个新指针指向栈顶节点
        lineStack * p=stack;
        //更新头指针
        stack=stack->next;
        printf("出栈元素：%d ",p->data);
        if (stack) {
            printf("新栈顶元素：%d\n",stack->data);
        }else{
            printf("栈已空\n");
        }
        free(p);
    }else{
        printf("栈内没有元素");
        return stack;
    }
    return stack;
}
```

代码中通过使用 if 判断语句，避免了用户执行"栈已空却还要数据出栈"错误操作。

###### 3.3.3 总结

本节，通过采用头插法操作数据的单链表实现了链栈结构，这里给出链栈及基本操作的C语言完整代码：

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct lineStack{
    int data;
    struct lineStack * next;
}lineStack;
lineStack* push(lineStack * stack,int a){
    lineStack * line=(lineStack*)malloc(sizeof(lineStack));
    line->data=a;
    line->next=stack;
    stack=line;
    return stack;
}
lineStack * pop(lineStack * stack){
    if (stack) {
        lineStack * p=stack;
        stack=stack->next;
        printf("弹栈元素：%d ",p->data);
        if (stack) {
            printf("栈顶元素：%d\n",stack->data);
        }else{
            printf("栈已空\n");
        }
        free(p);
    }else{
        printf("栈内没有元素");
        return stack;
    }
    return stack;
}
int main() {
    lineStack * stack=NULL;
    stack=push(stack, 1);
    stack=push(stack, 2);
    stack=push(stack, 3);
    stack=push(stack, 4);
    stack=pop(stack);
    stack=pop(stack);
    stack=pop(stack);
    stack=pop(stack);
    stack=pop(stack);
    return 0;
}
```

程序运行结果为：

```shell
弹栈元素：4 栈顶元素：3
弹栈元素：3 栈顶元素：2
弹栈元素：2 栈顶元素：1
弹栈元素：1 栈已空
栈内没有元素
```



##### 3.4 什么是队列 

队列，和栈一样，也是一种对数据的"存"和"取"有严格要求的线性存储结构。与栈结构不同的是，队列的两端都"开口"，要求数据只能从一端进，从另一端出，如图 1 所示：


![队列存储结构](http://data.biancheng.net/uploads/allimg/181203/2-1Q203200556309.gif)

<center>图 1 队列存储结构</center>

通常，称进数据的一端为 "队尾"，出数据的一端为 "队头"，数据元素进队列的过程称为 "入队"，出队列的过程称为 "出队"。

不仅如此，队列中数据的进出要遵循 "先进先出" 的原则，即最先进队列的数据元素，同样要最先出队列。拿图 1 中的队列来说，从数据在队列中的存储状态可以分析出，元素 1 最先进队，其次是元素 2，最后是元素 3。此时如果将元素 3 出队，根据队列 "先进先出" 的特点，元素 1 要先出队列，元素 2 再出队列，最后才轮到元素 3 出队列。

栈和队列不要混淆，栈结构是一端封口，特点是"先进后出"；而队列的两端全是开口，特点是"先进先出"。

因此，数据从表的一端进，从另一端出，且遵循 "先进先出" 原则的线性存储结构就是队列。

###### 3.4.1 队列的实现

队列存储结构的实现有以下两种方式：

1. [顺序队列](http://data.biancheng.net/view/173.html)：在顺序表的基础上实现的队列结构；
2. [链队列](http://data.biancheng.net/view/174.html)：在链表的基础上实现的队列结构；


两者的区别仅是顺序表和链表的区别，即在实际的物理空间中，数据集中存储的队列是顺序队列，分散存储的队列是链队列。

###### 3.4.2 队列的实际应用

实际生活中，队列的应用随处可见，比如排队买 XXX、医院的挂号系统等，采用的都是队列的结构。

拿排队买票来说，所有的人排成一队，先到者排的就靠前，后到者只能从队尾排队等待，队中的每个人都必须等到自己前面的所有人全部买票成功并从队头出队后，才轮到自己买票。这就不是典型的队列结构吗？

明白了什么是队列，接下来开始系统地学习顺序队列和链队列。



##### 3.5 顺序队列及其（C语言）实现详解

顺序队列，即采用顺序表模拟实现的队列结构。

我们知道，队列具有以下两个特点：

1. 数据从队列的一端进，另一端出；
2. 数据的入队和出队遵循"先进先出"的原则；


因此，只要使用顺序表按以上两个要求操作数据，即可实现顺序队列。首先来学习一种最简单的实现方法。

###### 3.5.1 顺序队列简单实现

由于顺序队列的底层使用的是数组，因此需预先申请一块足够大的内存空间初始化顺序队列。除此之外，为了满足顺序队列中数据从队尾进，队头出且先进先出的要求，我们还需要定义两个指针（top 和 rear）分别用于指向顺序队列中的队头元素和队尾元素，如图1 所示：


![顺序队列实现示意图](http://data.biancheng.net/uploads/allimg/181204/2-1Q204202R4539.gif)

<center>图 1 顺序队列实现示意图</center>


由于顺序队列初始状态没有存储任何元素，因此 top 指针和 rear 指针重合，且由于顺序队列底层实现靠的是数组，因此 top 和 rear 实际上是两个变量，它的值分别是队头元素和队尾元素所在数组位置的下标。

在图 1 的基础上，当有数据元素进队列时，对应的实现操作是将其存储在指针 rear 指向的数组位置，然后 rear+1；当需要队头元素出队时，仅需做 top+1 操作。

例如，在图 1 基础上将 `{1,2,3,4}` 用顺序队列存储的实现操作如图 2 所示：


![数据进顺序队列的过程实现示意图](http://data.biancheng.net/uploads/allimg/181204/2-1Q20420293O01.gif)

<center>图 2 数据进顺序队列的过程实现示意图</center>


在图 2 基础上，顺序队列中数据出队列的实现过程如图 3 所示：


![数据出顺序队列的过程示意图](http://data.biancheng.net/uploads/allimg/181204/2-1Q204202950120.gif)

<center>图 3 数据出顺序队列的过程示意图</center>


因此，使用顺序表实现顺序队列最简单方法的 C 语言实现代码为：

```c
#include <stdio.h>
int enQueue(int *a,int rear,int data){
    a[rear]=data;
    rear++;
    return rear;
}
void deQueue(int *a,int front,int rear){
    //如果 front==rear，表示队列为空
    while (front!=rear) {
        printf("出队元素：%d\n",a[front]);
        front++;
    }
}
int main() {
    int a[100];
    int front,rear;
    //设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址
    front=rear=0;
    //入队
    rear=enQueue(a, rear, 1);
    rear=enQueue(a, rear, 2);
    rear=enQueue(a, rear, 3);
    rear=enQueue(a, rear, 4);
    //出队
    deQueue(a, front, rear);
    return 0;
}
```

程序输出结果：

```
出队元素：1
出队元素：2
出队元素：3
出队元素：4
```



###### 3.5.2 此方法存在的问题

先来分析以下图 2b) 和图 3b)。图 2b) 是所有数据进队成功的示意图，而图 3b) 是所有数据全部出队后的示意图。通过对比两张图，你会发现，指针 top 和 rear 重合位置指向了 a[4] 而不再是 a[0]。也就是说，整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。

顺序队列整体后移造成的影响是：

- 顺序队列之前的数组存储空间将无法再被使用，造成了空间浪费；
- 如果顺序表申请的空间不足够大，则直接造成程序中数组 a 溢出，产生溢出错误；


为了避免以上两点，我建议初学者使用下面的方法实现顺序队列。

###### 3.5.3 顺序队列另一种实现方法

既然明白了上面这种方法的弊端，那么我们可以试着在它的基础上对其改良。

为了解决以上两个问题，可以使用巧妙的方法将顺序表打造成一个环状表，如图 4 所示：


![环状顺序队列](http://data.biancheng.net/uploads/allimg/181204/2-1Q204203432215.gif)

<center>图 4 环状顺序队列</center> 


图 4 只是一个想象图，在真正的实现时，没必要真创建这样一种结构，我们还是使用之前的顺序表，也还是使用之前的程序，只需要对其进行一点小小的改变：

```c
#include <stdio.h>
#define max 5//表示顺序表申请的空间大小
int enQueue(int *a,int front,int rear,int data){
    //添加判断语句，如果rear超过max，则直接将其从a[0]重新开始存储，如果rear+1和front重合，则表示数组已满
    if ((rear+1)%max==front) {
        printf("空间已满");
        return rear;
    }
    a[rear%max]=data;
    rear++;
    return rear;
}
int  deQueue(int *a,int front,int rear){
    //如果front==rear，表示队列为空
    if(front==rear%max) {
        printf("队列为空");
        return front;
    }
    printf("%d ",a[front]);
    //front不再直接 +1，而是+1后同max进行比较，如果=max，则直接跳转到 a[0]
    front=(front+1)%max;
    return front;
}
int main() {
    int a[max];
    int front,rear;
    //设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址
    front=rear=0;
    //入队
    rear=enQueue(a,front,rear, 1);
    rear=enQueue(a,front,rear, 2);
    rear=enQueue(a,front,rear, 3);
    rear=enQueue(a,front,rear, 4);
    //出队
    front=deQueue(a, front, rear);
    //再入队
    rear=enQueue(a,front,rear, 5);
    //再出队
    front=deQueue(a, front, rear);
    //再入队
    rear=enQueue(a,front,rear, 6);
    //再出队
    front=deQueue(a, front, rear);
    front=deQueue(a, front, rear);
    front=deQueue(a, front, rear);
    front=deQueue(a, front, rear);
    return 0;
}
```

程序运行结果：

```shell
1 2 3 4 5 6
```

使用此方法需要注意的是，顺序队列在判断数组是否已满时，出现下面情况：

- 当队列为空时，队列的头指针等于队列的尾指针；
- 当数组满员时，队列的头指针等于队列的尾指针；


顺序队列的存储状态不同，但是判断条件相同。为了对其进行区分，最简单的解决办法是：牺牲掉数组中的一个存储空间，判断数组满员的条件是：尾指针的下一个位置和头指针相遇，就说明数组满了，即程序中第 5 行所示。

##### 3.6 链式队列 

>http://data.biancheng.net/view/174.html



#### 四 字符串和多维数组

##### 4.1 什么是串存储结构 

数据结构中，字符串要单独用一种存储结构来存储，称为串存储结构。这里的串指的就是字符串。

严格意义上讲，串存储结构也是一种线性存储结构，因为字符串中的字符之间也具有"一对一"的逻辑关系。只不过，与之前所学的线性存储结构不同，串结构只用于存储字符类型的数据。

无论学习哪种编程语言，操作最多的总是字符串。数据结构中，根据串中存储字符的数量及特点，对一些特殊的串进行了命名，比如说：

- 空串：存储 0 个字符的串，例如 S = ""（双引号紧挨着）；
- 空格串：只包含空格字符的串，例如 S = "   "（双引号包含 5 个空格）；
- 子串和主串：假设有两个串 a 和 b，如果 a 中可以找到几个连续字符组成的串与 b 完全相同，则称 a 是 b 的主串，b 是 a 的子串。例如，若 a = "shujujiegou"，b = "shuju"，由于 a 中也包含 "shuju"，因此串 a 和串 b 是主串和子串的关系；


需要注意的是，空格串和空串不同，空格串中含有字符，只是都是空格而已。另外，只有串 b 整体出现在串 a 中，才能说 b 是 a 的子串，比如 "shujiejugou" 和 "shuju" 就不是主串和子串的关系。

另外，对于具有主串和子串关系的两个串，通常会让你用算法找到子串在主串的位置。子串在主串中的位置，指的是子串首个字符在主串中的位置。

例如，串 a = "shujujiegou"，串 b = "jiegou"，通过观察，可以判断 a 和 b 是主串和子串的关系，同时子串 b 位于主串 a 中第 6 的位置，因为在串 a 中，串 b 首字符 'j' 的位置是 6。

本章，我们会学习两种模式匹配算法专门解决此类问题。

###### 4.1.1 串存储结构的具体实现

存储一个字符串，数据结构包含以下 3 种具体存储结构：

1. 定长顺序存储：实际上就是用普通数组（又称静态数组）存储。例如 C 语言使用普通数据存储字符串的代码为 char a[20] = "data.biancheng.net"；
2. 堆分配存储：用动态数组存储字符串；
3. 块链存储：用链表存储字符串；

以上 3 种存储结构会在后续文章中作详细介绍。

##### 4.2 串的存储

> http://data.biancheng.net/view/177.html 



##### 4.3 串的算法 

>bmp 算法 
>
>kmp 算法  http://data.biancheng.net/view/180.html



##### 4.4 什么是数组

前面学习数据结构的过程中，总是使用数组作为顺序表的底层实现，给我们一种 "数据结构中，数组的作用就是实现顺序表" 的错误认识。其实，数组的作用远不止于此。

本节将从数据结构的角度讲解数组存储结构。

本节所讲的数组，要将其视为一种存储结构，与平时使用的数组基本数据类型区分开。

一说起数组，我们的印象中数组往往是某一门编程语言中包含的具体数据类型，其实不然。

从本质上讲，数组与顺序表、链表、栈和队列一样，都用来存储具有 "一对一" 逻辑关系数据的线性存储结构。只因各编程语言都默认将数组作为基本数据类型，使初学者对数组有了 "只是基本数据类型，不是存储结构" 的误解。

不仅如此，数组和其他线性存储结构不同，顺序表、链表、栈和队列存储的都是不可再分的数据元素（如数字 5、字符 'a' 等），而数组既可以用来存储不可再分的数据元素，也可以用来存储像顺序表、链表这样的数据结构。

比如说，数组可以直接存储多个顺序表。我们知道，顺序表的底层实现还是数组，因此等价于数组中继续存储数组。这与平时使用的二维数组类似。

根据数组中存储数据之间逻辑结构的不同，数组可细分为一维数组、二维数组、...、n 维数组：

- 一维数组，指的是存储不可再分数据元素的数组，如图1 所示；


  ![一维数组存储结构示意图](http://data.biancheng.net/uploads/allimg/181214/2-1Q21419542I92.gif)

  <center>图 1 一维数组存储结构示意图</center>

- 二维数组，指的存储一维数组的一维数组，如图 2 所示；


  ![二维数组存储结构示意图](http://data.biancheng.net/uploads/allimg/181214/2-1Q214195P0Z9.gif)

  <center>图 2 二维数组存储结构示意图</center>

- n 维数组，指的是存储 n-1 维数组的一维数组；

注意，无论数组的维数是多少，数组中的数据类型都必须一致。

由此，我们可以得出这样一个结论，一维数组结构是线性表

的基本表现形式，而 n 维数组可理解为是对线性存储结构的一种扩展。

##### 4.5 数组的顺序存储及实现



#### 五 树和二叉树

##### 5.1 树的存储结构 

之前介绍的所有的数据结构都是线性存储结构。本章所介绍的树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。

![img](http://data.biancheng.net/uploads/allimg/170830/2-1FS0094003158.png)

​                                 

​                                                                                                    (A)                                     (B) 

<center>图 1 树的示例</center>


图 1(A) 是使用树结构存储的集合 {A,B,C,D,E,F,G,H,I,J,K,L,M} 的示意图。对于数据 A 来说，和数据 B、C、D 有关系；对于数据 B 来说，和 E、F 有关系。这就是“一对多”的关系。

将具有“一对多”关系的集合中的数据元素按照图 1（A）的形式进行存储，整个存储形状在逻辑结构上看，类似于实际生活中倒着的树（图 1（B）倒过来），所以称这种存储结构为“树型”存储结构。

###### 5.1.1 树的结点

**结点**：使用树结构存储的每一个数据元素都被称为“结点”。例如，图 1（A）中，数据元素 A 就是一个结点；

**父结点（双亲结点）、子结点和兄弟结点**：对于图 1（A）中的结点 A、B、C、D 来说，A 是 B、C、D 结点的父结点（也称为“双亲结点”），而 B、C、D 都是 A 结点的子结点（也称“孩子结点”）。对于 B、C、D 来说，它们都有相同的父结点，所以它们互为兄弟结点。

**树根结点（简称“根结点”）**：每一个非空树都有且只有一个被称为根的结点。图 1（A）中，结点A就是整棵树的根结点。

> 树根的判断依据为：如果一个结点没有父结点，那么这个结点就是整棵树的根结点。

**叶子结点**：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）。例如图 1（A）中，结点 K、L、F、G、M、I、J 都是这棵树的叶子结点。

###### 5.1.2 子树和空树

**子树**：如图 1（A）中，整棵树的根结点为结点 A，而如果单看结点 B、E、F、K、L 组成的部分来说，也是棵树，而且节点 B 为这棵树的根结点。所以称 B、E、F、K、L 这几个结点组成的树为整棵树的子树；同样，结点 E、K、L 构成的也是一棵子树，根结点为 E。

> 注意：单个结点也是一棵树，只不过根结点就是它本身。图 1（A）中，结点 K、L、F 等都是树，且都是整棵树的子树。

知道了子树的概念后，**树也可以这样定义：树是由根结点和若干棵子树构成的。**

**空树**：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。

> 补充：在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集。例如，图 1（A）中，除了根结点 A，其余元素又各自构成了三个子树，根结点分别为 B、C、D，这三个子树相互之间没有相同的结点。如果有，就破坏了树的结构，不能算做是一棵树。

###### 5.1.3 结点的度和层次

对于一个结点，拥有的子树数（结点有多少分支）称为结点的度（Degree）。例如，图 1（A）中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。

**一棵树的度是树内各结点的度的最大值。图 1（A）表示的树中，各个结点的度的最大值为 3，所以，整棵树的度的值是 3。**

结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。对于图 1（A）来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。

一棵树的深度（高度）是树中结点所在的最大的层次。图 1（A）树的深度为 4。

如果两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。例如，图 1（A）中，结点 G 和 E、F、H、I、J 的父结点都在第二层，所以之间为堂兄弟的关系。

###### 5.1.4 有序树和无序树

如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为**有序树**；反之称为**无序树**。

> 在有序树中，一个结点最左边的子树称为"第一个孩子"，最右边的称为"最后一个孩子"。

拿图 1（A）来说，如果是其本身是一棵有序树，则以结点 B 为根结点的子树为整棵树的第一个孩子，以结点 D 为根结点的子树为整棵树的最后一个孩子。

###### 5.1.5 森林

由 m（m >= 0）个互不相交的树组成的集合被称为森林。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。

前面讲到，树可以理解为是由根结点和若干子树构成的，而这若干子树本身是一个森林，所以，树还可以理解为是由根结点和森林组成的。用一个式子表示为：

```c
Tree =（root,F）
```

其中，root 表示树的根结点，F 表示由 m（m >= 0）棵树组成的森林。

###### 5.1.6 树的表示方法

除了图 1（A）表示树的方法外，还有其他表示方法：

![img](http://data.biancheng.net/uploads/allimg/170830/2-1FS00952413Y.png)

  <center>（A）                     （B）</center>

<center>图2 树的表示形式</center>

图 2（A）是以嵌套的集合的形式表示的（集合之间绝不能相交，即图中任意两个圈不能相交）。

图 2（B）使用的是凹入表示法（了解即可），表示方式是：最长条为根结点，相同长度的表示在同一层次。例如 B、C、D 长度相同，都为 A 的子结点，E 和 F 长度相同，为 B 的子结点，K 和 L 长度相同，为 E 的子结点，依此类推。

最常用的表示方法是使用[广义表](http://data.biancheng.net/view/189.html)的方式。图 1（A）用广义表表示为：

[(A , ( B ( E ( K , L ) , F ) , C ( G ) , D ( H ( M ) , I , J ) ) )]()

###### 5.1.7 总结

树型存储结构类似于家族的族谱，各个结点之间也同样可能具有父子、兄弟、表兄弟的关系。本节中，要重点理解树的根结点和子树的定义，同时要会计算树中各个结点的度和层次，以及树的深度。



##### 5.2 什么是二叉树 

简单地理解，满足以下两个条件的树就是二叉树：

1. 本身是有序树；
2. 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；


例如，图1a) 就是一棵二叉树，而图 1b) 则不是。


![二叉树示意图](http://data.biancheng.net/uploads/allimg/181226/2-1Q226195I0M1.gif)

<center>图 1 二叉树示意图</center>

###### 5.2.1 二叉树的性质

经过前人的总结，二叉树具有以下几个性质：

1. 二叉树中，第 i 层最多有 2i-1 个结点。 

   > 此处 为 2^（i-1）

2. 如果二叉树的深度为 K，那么此二叉树最多有 2K-1 个结点。

   > 此处为2^k  -1 

3. 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。

> 性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。
> 同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2*n2。所以，n 用另外一种方式表示为 n=n1+2*n2+1。
> 两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。


二叉树还可以继续分类，衍生出**满二叉树**和完全二叉树。

###### 5.2.2 满二叉树(对完全二叉树和满二叉树的定义有争议)

>https://www.cnblogs.com/myjavascript/articles/4092746.html   满二叉树和完全二叉树定义

如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为**满二叉树**。（这个定义我觉得不对）

>应该加一个叶子结点都在最后一层(或者同一层)


![满二叉树示意图](http://data.biancheng.net/uploads/allimg/181226/2-1Q226195949495.gif)

<center>图 2 满二叉树示意图</center>


如图 2 所示就是一棵满二叉树。

满二叉树除了满足普通二叉树的性质，还具有以下性质：

1. 满二叉树中第 i 层的节点数为 2n-1 个。
2. 深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。
3. 满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。
4. 具有 n 个节点的满二叉树的深度为 log2(n+1)。

###### 5.2.3 完全二叉树

如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。


![完全二叉树示意图](http://data.biancheng.net/uploads/allimg/181226/2-1Q22620003J18.gif)

<center>图 3 完全二叉树示意图</center>


如图 3a) 所示是一棵完全二叉树，图 3b) 由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树。

完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。

> ⌊log2n⌋ 表示取小于 log2n 的最大整数。例如，⌊log24⌋ = 2，而 ⌊log25⌋ 结果也是 2。

对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：

1. 当 i>1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）
2. 如果 2*i>n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2*i 。
3. 如果 2*i+1>n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2*i+1 。

###### 5.2.4 总结

本节介绍了什么是二叉树，以及二叉树的性质，同时还介绍了满二叉树和完全二叉树以及各自所特有的性质，初学者需理解并牢记这些性质，才能更熟练地使用二叉树解决实际问题。



##### 5.3 二叉树的存储结构

###### 5.3.1 二叉树的顺序存储结构 

二叉树的存储结构有两种，分别为顺序存储和链式存储。本节先介绍二叉[树](http://data.biancheng.net/view/23.html)的顺序存储结构。

二叉树的顺序存储，指的是使用[顺序表](http://data.biancheng.net/view/158.html)（[数组](http://data.biancheng.net/view/181.html)）存储二叉树。需要注意的是，**顺序存储只适用于完全二叉树。**换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。

有读者会说，满二叉树也可以使用顺序存储。要知道，满二叉树也是完全二叉树，因为它满足完全二叉树的所有特征。

普通二叉树转完全二叉树的方法很简单，只需给二叉树额外添加一些节点，将其"拼凑"成完全二叉树即可。如图1 所示：


![img](http://data.biancheng.net/uploads/allimg/170830/2-1FS01056261L.png)

<center>图 1 普通二叉树的转化</center>


图 1 中，左侧是普通二叉树，右侧是转化后的完全（满）二叉树。

解决了二叉树的转化问题，接下来学习如何顺序存储完全（满）二叉树。

完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。


![img](http://data.biancheng.net/uploads/allimg/181227/2-1Q22H02935422.gif)

<center>图 2 完全二叉树示意图</center>


例如，存储图 2 所示的完全二叉树，其存储状态如图 3 所示：


![img](http://data.biancheng.net/uploads/allimg/170830/2-1FS0105529235.png)

<center>图 3 完全二叉树存储状态示意图</center>


同样，存储由普通二叉树转化来的完全二叉树也是如此。例如，图 1 中普通二叉树的数组存储状态如图 4 所示：


![img](http://data.biancheng.net/uploads/allimg/170830/2-1FS0105A9146.png)

<center>图 4 普通二叉树的存储状态</center>


由此，我们就实现了完全二叉树的顺序存储。

不仅如此，从顺序表中还原完全二叉树也很简单。我们知道，完全二叉树具有这样的性质，将树中节点按照层次并从左到右依次标号（1,2,3,...），若节点 i 有左右孩子，则其左孩子节点为 2*i，右孩子节点为 2*i+1。此性质可用于还原数组中存储的完全二叉树，也就是实现由图 3 到图 2、由图 4 到图 1 的转变。

> 编写本节实现代码，需要对二叉树进行层次遍历，这个知识点本章有单独一节做详细介绍，这里不再给出具体的代码实现。

###### 5.3.2 二叉树的链式存储结构 

上一节讲了二叉树的顺序存储，通过学习你会发现，其实二叉[树](http://data.biancheng.net/view/23.html)并不适合用[数组](http://data.biancheng.net/view/181.html)存储，因为并不是每个二叉树都是完全二叉树，普通二叉树使用[顺序表](http://data.biancheng.net/view/158.html)

存储或多或多会存在空间浪费的现象。

本节我们学习二叉树的链式存储结构。

![普通二叉树示意图](http://data.biancheng.net/uploads/allimg/181228/2-1Q22R02H9133.gif)

<center>图 1 普通二叉树示意图</center>


如图 1 所示，此为一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用[链表](http://data.biancheng.net/view/160.html)存储即可。因此，图 1 对应的链式存储结构如图 2 所示：


![二叉树链式存储结构示意图](http://data.biancheng.net/uploads/allimg/181228/2-1Q22R035341H.gif)

<center>图 2 二叉树链式存储结构示意图</center>


由图 2 可知，采用链式存储二叉树时，其节点结构由 3 部分构成（如图 3 所示）：

- 指向左孩子节点的指针（Lchild）；
- 节点存储的数据（data）；
- 指向右孩子节点的指针（Rchild）；

![二叉树节点结构](http://data.biancheng.net/uploads/allimg/181228/2-1Q22R02Q6392.gif)

<center>图 3 二叉树节点结构</center>

c代码待补充

其实，二叉树的链式存储结构远不止图 2 所示的这一种。例如，在某些实际场景中，可能会做 "查找某节点的父节点" 的操作，这时可以在节点结构中再添加一个指针域，用于各个节点指向其父亲节点，如图 4 所示：


![自定义二叉树的链式存储结构](http://data.biancheng.net/uploads/allimg/181228/2-1Q22R0360I09.gif)

<center>图 4 自定义二叉树的链式存储结构</center>

这样的链表结构，通常称为三叉链表。

利用图 4 所示的三叉链表，我们可以很轻松地找到各节点的父节点。因此，在解决实际问题时，用合适的链表结构存储二叉树，可以起到事半功倍的效果。



##### 5.4 二叉树遍历算法 

>http://data.biancheng.net/view/195.html  二叉树遍历算法思想
>
>遍历算法顺序针对的是中间结点的遍历顺序，中间结点在 先 中 后 遍历顺序。

###### 5.4.1 先序遍历  

二叉树先序遍历的实现思想是：

1. 访问根节点；
2. 访问当前节点的左子[树](http://data.biancheng.net/view/23.html)；
3. 若当前节点无左子树，则访问当前节点的右子树；

![img](http://data.biancheng.net/uploads/allimg/170830/2-1FS01325394F.png)

<center>图 1 二叉树</center>

以图 1 为例，采用先序遍历的思想遍历该二叉树的过程为：

1. 访问该二叉树的根节点，找到 1；
2. 访问节点 1 的左子树，找到节点 2；
3. 访问节点 2 的左子树，找到节点 4；
4. 由于访问节点 4 左子树失败，且也没有右子树，因此以节点 4 为根节点的子树遍历完成。但节点 2 还没有遍历其右子树，因此现在开始遍历，即访问节点 5；
5. 由于节点 5 无左右子树，因此节点 5 遍历完成，并且由此以节点 2 为根节点的子树也遍历完成。现在回到节点 1 ，并开始遍历该节点的右子树，即访问节点 3；
6. 访问节点 3 左子树，找到节点 6；
7. 由于节点 6 无左右子树，因此节点 6 遍历完成，回到节点 3 并遍历其右子树，找到节点 7；
8. 节点 7 无左右子树，因此以节点 3 为根节点的子树遍历完成，同时回归节点 1。由于节点 1 的左右子树全部遍历完成，因此整个二叉树遍历完成；


因此，图 1 中二叉树采用先序遍历得到的序列为：

~~~
1 2 4 5 3 6 7
~~~

递归与非递归实现代码待补充

###### 5.4.2 中序遍历 

二叉树中序遍历的实现思想是：

1. 访问当前节点的左子[树](http://data.biancheng.net/view/23.html)；
2. 访问根节点；
3. 访问当前节点的右子树；

![img](http://data.biancheng.net/uploads/allimg/170830/2-1FS01325394F.png)

<center>图 1 二叉树</center>

以图 1 为例，采用中序遍历的思想遍历该二叉树的过程为：

1. 访问该二叉树的根节点，找到 1；
2. 遍历节点 1 的左子树，找到节点 2；
3. 遍历节点 2 的左子树，找到节点 4；
4. 由于节点 4 无左孩子，因此找到节点 4，并遍历节点 4 的右子树；
5. 由于节点 4 无右子树，因此节点 2 的左子树遍历完成，访问节点 2；
6. 遍历节点 2 的右子树，找到节点 5；
7. 由于节点 5 无左子树，因此访问节点 5 ，又因为节点 5 没有右子树，因此节点 1 的左子树遍历完成，访问节点 1 ，并遍历节点 1 的右子树，找到节点 3；
8. 遍历节点 3 的左子树，找到节点 6；
9. 由于节点 6 无左子树，因此访问节点 6，又因为该节点无右子树，因此节点 3 的左子树遍历完成，开始访问节点 3 ，并遍历节点 3 的右子树，找到节点 7；
10. 由于节点 7 无左子树，因此访问节点 7，又因为该节点无右子树，因此节点 1 的右子树遍历完成，即整棵树遍历完成；


因此，图 1 中二叉树采用中序遍历得到的序列为：

~~~
4 2 5 1 6 3 7
~~~

递归与非递归实现代码待补充

###### 5.4.3 后序遍历

二叉树后序遍历的实现思想是：从根节点出发，依次遍历各节点的左右子[树](http://data.biancheng.net/view/23.html)，直到当前节点左右子树遍历完成后，才访问该节点元素。


![img](http://data.biancheng.net/uploads/allimg/170830/2-1FS01325394F.png)

<center>图 1 二叉树</center>

如图 1 中，对此二叉树进行后序遍历的操作过程为：

- 图，遍历该节点的左子树（以节点 2 为根节点）；
- 遍历节点 2 的左子树（以节点 4 为根节点）；
- 由于节点 4 既没有左子树，也没有右子树，此时访问该节点中的元素 4，并回退到节点 2 ，遍历节点 2 的右子树（以 5 为根节点）；
- 由于节点 5 无左右子树，因此可以访问节点 5 ，并且此时节点 2 的左右子树也遍历完成，因此也可以访问节点 2；
- 此时回退到节点 1 ，开始遍历节点 1 的右子树（以节点 3 为根节点）；
- 遍历节点 3 的左子树（以节点 6 为根节点）；
- 由于节点 6 无左右子树，因此访问节点 6，并回退到节点 3，开始遍历节点 3 的右子树（以节点 7 为根节点）；
- 由于节点 7 无左右子树，因此访问节点 7，并且节点 3 的左右子树也遍历完成，可以访问节点 3；节点 1 的左右子树也遍历完成，可以访问节点 1；
- 到此，整棵树的遍历结束。

由此，对图 1 中二叉树进行后序遍历的结果为：

~~~ 
4 5 2 6 7 3 1
~~~



前边介绍了二叉树的先序、中序和后序的遍历算法，运用了[栈](http://data.biancheng.net/view/169.html)的数据结构，主要思想就是按照先左子[树](http://data.biancheng.net/view/23.html)后右子树的顺序依次遍历树中各个结点。

本节介绍另外一种遍历方式：按照二叉树中的层次从左到右依次遍历每层中的结点。具体的实现思路是：通过使用[队列](http://data.biancheng.net/view/172.html)的数据结构，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果。

![img](http://data.biancheng.net/uploads/allimg/170830/2-1FS0143134W9.png)

<center>图1 二叉树</center>

层次遍历的实现过程

例如，层次遍历图 1 中的二叉树：

- 首先，根结点 1 入队；
- 根结点 1 出队，出队的同时，将左孩子 2 和右孩子 3 分别入队；
- 队头结点 2 出队，出队的同时，将结点 2 的左孩子 4 和右孩子 5 依次入队；
- 队头结点 3 出队，出队的同时，将结点 3 的左孩子 6 和右孩子 7 依次入队；
- 不断地循环，直至队列内为空。



##### 5.5 树的存储结构 

###### 5.5.1 树的双亲表示法 

前面讲了二叉树的顺序存储和链式存储，本节来学习如何存储具有普通[树](http://data.biancheng.net/view/23.html)结构的数据。


![普通树存储结构](http://data.biancheng.net/uploads/allimg/181231/2-1Q2312025512N.gif)

<center>图 1 普通树存储结构2</center>


如图 1 所示，这是一棵普通的树，该如何存储呢？通常，存储具有普通树结构数据的方法有 3 种：

1. 双亲表示法；
2. [孩子表示法](http://data.biancheng.net/view/197.html)；
3. [孩子兄弟表示法](http://data.biancheng.net/view/198.html)；


本节先来学习双亲表示法。

双亲表示法采用[顺序表](http://data.biancheng.net/view/158.html)（也就是[数组](http://data.biancheng.net/view/181.html)）存储普通树，其实现的核心思想是：顺序存储各个节点的同时，给各节点附加一个记录其父节点位置的变量。

注意，根节点没有父节点（父节点又称为双亲节点），因此根节点记录父节点位置的变量通常置为 -1。

例如，采用双亲表示法存储图 1 中普通树，其存储状态如图 2 所示：


![双亲表示法存储普通树示意图](http://data.biancheng.net/uploads/allimg/181231/2-1Q231202645110.gif)

<center>图 2 双亲表示法存储普通树示意图</center>

###### 5.5.2 孩子表示法 

前面学习了如何用[双亲表示法](http://data.biancheng.net/view/196.html)存储普通[树](http://data.biancheng.net/view/23.html)，本节再学习一种存储普通树的方法——孩子表示法。

孩子表示法存储普通树采用的是 "[顺序表](http://data.biancheng.net/view/158.html)+[链表](http://data.biancheng.net/view/160.html)" 的组合结构，其存储过程是：从树的根节点开始，使用顺序表依次存储树中各个节点，需要注意的是，与双亲表示法不同，孩子表示法会给各个节点配备一个链表，用于存储各节点的孩子节点位于顺序表中的位置。

> 如果节点没有孩子节点（叶子节点），则该节点的链表为空链表。

例如，使用孩子表示法存储图1a) 中的普通树，则最终存储状态如图 1b) 所示：


![img](http://data.biancheng.net/uploads/allimg/190101/2-1Z101115601O6.gif)

<center>图 1 孩子表示法存储普通树示意图</center>

###### 5.5.3 孩子兄弟表示法

前面讲解了存储普通[树](http://data.biancheng.net/view/23.html)的[双亲表示法](http://data.biancheng.net/view/196.html)和[孩子表示法](http://data.biancheng.net/view/197.html)，本节来讲解最后一种常用方法——孩子兄弟表示法。


![普通树示意图](http://data.biancheng.net/uploads/allimg/190101/2-1Z10112303S92.gif)

<center>图1 普通树示意图</center>


树结构中，位于同一层的节点之间互为兄弟节点。例如，图 1 的普通树中，节点 A、B 和 C 互为兄弟节点，而节点 D、E 和 F 也互为兄弟节点。

孩子兄弟表示法，采用的是链式存储结构，其存储树的实现思想是：从树的根节点开始，依次用[链表](http://data.biancheng.net/view/160.html)存储各个节点的孩子节点和兄弟节点。

因此，该链表中的节点应包含以下 3 部分内容（如图 2 所示）：

1. 节点的值；
2. 指向孩子节点的指针；
3. 指向兄弟节点的指针；

![节点结构示意图](http://data.biancheng.net/uploads/allimg/190101/2-1Z10112305G62.gif)

<center>图 2 节点结构示意图</center>


用 C 语言代码表示节点结构为：

```
#define ElemType chartypedef struct CSNode{    ElemType data;    struct CSNode * firstchild,*nextsibling;}CSNode,*CSTree;
```


以图 1 为例，使用孩子兄弟表示法进行存储的结果如图 3 所示:


![孩子兄弟表示法示意图](http://data.biancheng.net/uploads/allimg/190101/2-1Z101123113227.gif)

<center>图 3 孩子兄弟表示法示意图</center>


由图 3 可以看到，节点 R 无兄弟节点，其孩子节点是 A；节点 A 的兄弟节点分别是 B 和 C，其孩子节点为 D，依次类推。

实现图 3 中的 C 语言实现代码也很简单，根据图中链表的结构即可轻松完成链表的创建和使用，因此不再给出具体代码。

接下来观察图 1 和图 3。图 1 为原普通树，图 3 是由图 1 经过孩子兄弟表示法转化而来的一棵树，确切地说，图 3 是一棵二叉树

。因此可以得出这样一个结论，**即通过孩子兄弟表示法，任意一棵普通树都可以相应转化为一棵二叉树，换句话说，任意一棵普通树都有唯一的一棵二叉树于其对应。**

因此，孩子兄弟表示法可以作为将普通树转化为二叉树的最有效方法，通常又被称为"二叉树表示法"或"二叉链表表示法"。

##### 5.6 森林转换为二叉树  

前面介绍了普通[树](http://data.biancheng.net/view/23.html)转化为二叉树的[孩子兄弟表示法](http://data.biancheng.net/view/198.html)，本节来学习如何将森林转化为一整棵二叉树。

森林，指的是由 n（n>=2）棵互不相交的树组成的集合，如图1 所示。


![森林示意图](http://data.biancheng.net/uploads/allimg/190101/2-1Z10113315T93.gif)

<center>图 1 森林示意图</center>


在某些实际场景中，为了便于操作具有森林结构的数据，往往需要将森林转化为一整棵二叉树。

我们知道，任意一棵普通树都可以转化为二叉树，而森林是由多棵普通树构成的，因此自然也可以转化为二叉树，其转化方法是：

1. 首先将森林中所有的普通树各自转化为二叉树；
2. 将森林中第一棵树的树根作为整个森林的树根，其他树的根节点看作是第一棵树根节点的兄弟节点，采用孩子兄弟表示法将所有树进行连接；


例如，将图 2a) 中的森林转化为二叉树，则以上两个转化过程分别对应图 2 中的 b) 和 c) ：


![森林转化为二叉树的过程示意图](http://data.biancheng.net/uploads/allimg/190101/2-1Z1011332301D.gif)

<center>图 2 森林转化为二叉树的过程示意图</center>


如图 2 所示**，先将森林包含的所有普通树各自转化为二叉树，然后将其他树的根节点看作为第一棵二叉树的兄弟节点，采用孩子兄弟表示法进行连接。**

森林转化为二叉树，更多的是为了对森林中的节点做遍历操作。前面讲过，遍历二叉树有 4 种方法，分别是层次遍历、先序遍历、中序遍历和后序遍历。**转化前的森林与转化后的二叉树相比，其层次遍历和后序遍历的访问节点顺序不同，而前序遍历和中序遍历访问节点的顺序是相同的。**

以图 1 中的森林为例，其转化后的二叉树为图 2c)，两者比较，其先序遍历访问节点的顺序都是 `A B C D E F G H I J`；同样，中序遍历访问节点的顺序也相同，都是 `B C D A F E H J I G`。而后序遍历和层次遍历访问节点的顺序是不同的。

提示，由二叉树转化为森林的过程也就是森林转化二叉树的逆过程，也就是图 2 中由 c) 到 b) 再到 a) 的过程。



##### 5.7 哈夫曼树  

赫夫曼[树](http://data.biancheng.net/view/23.html)，别名“哈夫曼树”、“最优树”以及“最优二叉树”。学习哈夫曼树之前，首先要了解几个名词。

###### 5.7.1 哈夫曼树相关的几个名词

路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图1 中，从根结点到结点 a 之间的通路就是一条路径。

路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。

结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。

结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。

树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如图 1 中所示的这颗树的带权路径长度为：

> WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3

![img](http://data.biancheng.net/uploads/allimg/170905/2-1FZ509310DJ.png)

<center>图1 哈夫曼树</center>

###### 5.7.2 什么是哈夫曼树

当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。

在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：**权重越大的结点离树根越近**。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。

###### 5.7.3 构建哈夫曼树

对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：

1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；
2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；
3. 重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。

![img](http://data.biancheng.net/uploads/allimg/170905/2-1FZ509425D12.png)

<center>图 2 哈夫曼树的构建过程</center>

图 2 中，（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。

###### 5.7.4 哈弗曼树中结点结构

构建哈夫曼树时，首先需要确定树中结点的构成。由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。

所以，哈夫曼树中结点构成用代码表示为：

```c
//哈夫曼树结点结构
typedef struct {
    int weight;//结点权重
    int parent, left, right;//父结点、左孩子、右孩子在数组中的位置下标
}HTNode, *HuffmanTree;
```

###### 5.7.5 哈弗曼树中的查找算法

构建哈夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。

查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：

- 如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；
- 如果介于两个结点权重值之间，替换原来较大的结点；


实现代码：

```c
//HT数组中存放的哈夫曼树，end表示HT数组中存放结点的最终位置，s1和s2传递的是HT数组中权重值最小的两个结点在数组中的位置
void Select(HuffmanTree HT, int end, int *s1, int *s2)
{
    int min1, min2;
    //遍历数组初始下标为 1
    int i = 1;
    //找到还没构建树的结点
    while(HT[i].parent != 0 && i <= end){
        i++;
    }
    min1 = HT[i].weight;
    *s1 = i;
   
    i++;
    while(HT[i].parent != 0 && i <= end){
        i++;
    }
    //对找到的两个结点比较大小，min2为大的，min1为小的
    if(HT[i].weight < min1){
        min2 = min1;
        *s2 = *s1;
        min1 = HT[i].weight;
        *s1 = i;
    }else{
        min2 = HT[i].weight;
        *s2 = i;
    }
    //两个结点和后续的所有未构建成树的结点做比较
    for(int j=i+1; j <= end; j++)
    {
        //如果有父结点，直接跳过，进行下一个
        if(HT[j].parent != 0){
            continue;
        }
        //如果比最小的还小，将min2=min1，min1赋值新的结点的下标
        if(HT[j].weight < min1){
            min2 = min1;
            min1 = HT[j].weight;
            *s2 = *s1;
            *s1 = j;
        }
        //如果介于两者之间，min2赋值为新的结点的位置下标
        else if(HT[j].weight >= min1 && HT[j].weight < min2){
            min2 = HT[j].weight;
            *s2 = j;
        }
    }
}
```

> 注意：s1和s2传入的是实参的地址，所以函数运行完成后，实参中存放的自然就是哈夫曼树中权重值最小的两个结点在数组中的位置。

###### 5.7.6 构建哈弗曼树的代码实现

```c
//HT为地址传递的存储哈夫曼树的数组，w为存储结点权重值的数组，n为结点个数
void CreateHuffmanTree(HuffmanTree *HT, int *w, int n)
{
    if(n<=1) return; // 如果只有一个编码就相当于0
    int m = 2*n-1; // 哈夫曼树总节点数，n就是叶子结点
    *HT = (HuffmanTree) malloc((m+1) * sizeof(HTNode)); // 0号位置不用
    HuffmanTree p = *HT;
    // 初始化哈夫曼树中的所有结点
    for(int i = 1; i <= n; i++)
    {
        (p+i)->weight = *(w+i-1);
        (p+i)->parent = 0;
        (p+i)->left = 0;
        (p+i)->right = 0;
    }
    //从树组的下标 n+1 开始初始化哈夫曼树中除叶子结点外的结点
    for(int i = n+1; i <= m; i++)
    {
        (p+i)->weight = 0;
        (p+i)->parent = 0;
        (p+i)->left = 0;
        (p+i)->right = 0;
    }
    //构建哈夫曼树
    for(int i = n+1; i <= m; i++)
    {
        int s1, s2;
        Select(*HT, i-1, &s1, &s2);
        (*HT)[s1].parent = (*HT)[s2].parent = i;
        (*HT)[i].left = s1;
        (*HT)[i].right = s2;
        (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;
    }
}
```

###### 5.7.7 哈夫曼编码

哈夫曼编码就是在哈夫曼树的基础上构建的，这种编码方式最大的优点就是用最少的字符包含最多的信息内容。

根据发送信息的内容，通过统计文本中相同字符的个数作为每个字符的权值，建立哈夫曼树。对于树中的每一个子树，统一规定其左孩子标记为 0 ，右孩子标记为 1 。这样，用到哪个字符时，从哈夫曼树的根结点开始，依次写出经过结点的标记，最终得到的就是该结点的哈夫曼编码。

> 文本中字符出现的次数越多，在哈夫曼树中的体现就是越接近树根。编码的长度越短。

![img](http://data.biancheng.net/uploads/allimg/170905/2-1FZ5095536108.png)

<center>图 3 哈夫曼编码</center>

如图 3 所示，字符 a 用到的次数最多，其次是字符 b 。字符 a 在哈夫曼编码是 `0` ，字符 b 编码为 `10` ，字符 c 的编码为 `110` ，字符 d 的编码为 `111` 。

使用程序求哈夫曼编码有两种方法：

1. 从叶子结点一直找到根结点，逆向记录途中经过的标记。例如，图 3 中字符 c 的哈夫曼编码从结点 c 开始一直找到根结点，结果为：0 1 1 ，所以字符 c 的哈夫曼编码为：1 1 0（逆序输出）。
2. 从根结点出发，一直到叶子结点，记录途中经过的标记。例如，求图 3 中字符 c 的哈夫曼编码，就从根结点开始，依次为：1 1 0。


采用方法 1 的实现代码为：

```c
//HT为哈夫曼树，HC为存储结点哈夫曼编码的二维动态数组，n为结点的个数
void HuffmanCoding(HuffmanTree HT, HuffmanCode *HC,int n){
    *HC = (HuffmanCode) malloc((n+1) * sizeof(char *));
    char *cd = (char *)malloc(n*sizeof(char)); //存放结点哈夫曼编码的字符串数组
    cd[n-1] = '\0';//字符串结束符
   
    for(int i=1; i<=n; i++){
        //从叶子结点出发，得到的哈夫曼编码是逆序的，需要在字符串数组中逆序存放
        int start = n-1;
        //当前结点在数组中的位置
        int c = i;
        //当前结点的父结点在数组中的位置
        int j = HT[i].parent;
        // 一直寻找到根结点
        while(j != 0){
            // 如果该结点是父结点的左孩子则对应路径编码为0，否则为右孩子编码为1
            if(HT[j].left == c)
                cd[--start] = '0';
            else
                cd[--start] = '1';
            //以父结点为孩子结点，继续朝树根的方向遍历
            c = j;
            j = HT[j].parent;
        }
        //跳出循环后，cd数组中从下标 start 开始，存放的就是该结点的哈夫曼编码
        (*HC)[i] = (char *)malloc((n-start)*sizeof(char));
        strcpy((*HC)[i], &cd[start]);
    }
    //使用malloc申请的cd动态数组需要手动释放
    free(cd);
}
```

采用第二种算法的实现代码为：

```c
//HT为哈夫曼树，HC为存储结点哈夫曼编码的二维动态数组，n为结点的个数
void HuffmanCoding(HuffmanTree HT, HuffmanCode *HC,int n){
    *HC = (HuffmanCode) malloc((n+1) * sizeof(char *));
    int m=2*n-1;
    int p=m;
    int cdlen=0;
    char *cd = (char *)malloc(n*sizeof(char));
    //将各个结点的权重用于记录访问结点的次数，首先初始化为0
    for (int i=1; i<=m; i++) {
        HT[i].weight=0;
    }
    //一开始 p 初始化为 m，也就是从树根开始。一直到p为0
    while (p) {
        //如果当前结点一次没有访问，进入这个if语句
        if (HT[p].weight==0) {
            HT[p].weight=1;//重置访问次数为1
            //如果有左孩子，则访问左孩子，并且存储走过的标记为0
            if (HT[p].left!=0) {
                p=HT[p].left;
                cd[cdlen++]='0';
            }
            //当前结点没有左孩子，也没有右孩子，说明为叶子结点，直接记录哈夫曼编码
            else if(HT[p].right==0){
                (*HC)[p]=(char*)malloc((cdlen+1)*sizeof(char));
                cd[cdlen]='\0';
                strcpy((*HC)[p], cd);
            }
        }
        //如果weight为1，说明访问过一次，即是从其左孩子返回的
        else if(HT[p].weight==1){
            HT[p].weight=2;//设置访问次数为2
            //如果有右孩子，遍历右孩子，记录标记值 1
            if (HT[p].right!=0) {
                p=HT[p].right;
                cd[cdlen++]='1';
            }
        }
        //如果访问次数为 2，说明左右孩子都遍历完了，返回父结点
        else{
            HT[p].weight=0;
            p=HT[p].parent;
            --cdlen;
        }
    }
}
```



> 本节中介绍了两种遍历哈夫曼树获得哈夫曼编码的方法，同时也给出了各自完整的实现代码的函数，在完整代码中使用的是第一种逆序遍历哈夫曼树的方法。

###### 5.7.8 总结

![img](http://data.biancheng.net/uploads/allimg/170905/2-1FZ5095P9356.png)

<center>图 4 程序运行效果图</center>


本节的程序中对权重值分别为 2，8，7，6，5 的结点构建的哈夫曼树如图 4（A）所示。图 4（B）是另一个哈夫曼树，两棵树的带权路径长度相同。

程序运行效果图之所以是（A）而不是（B），原因是在构建哈夫曼树时，结点 2 和结点 5 构建的新的结点 7 存储在动态树组的最后面，所以，在程序继续选择两个权值最小的结点时，直接选择了的叶子结点 6 和 7 。



##### 5.8  二叉树 常见计算

本节要讨论的是当给定 n（n>=0）个结点时，可以构建多少种形态不同的[树](http://data.biancheng.net/view/23.html)。

> 如果两棵树中各个结点的位置都一一对应，可以说这两棵树相似。如果两棵树不仅相似，而且对应结点上的数据也相同，就可以说这两棵树等价。本节中，形态不同的树指的是互不相似的树。

前面介绍过，对于任意一棵普通树，通过[孩子兄弟表示法](http://data.biancheng.net/view/198.html)的转化，都可以找到唯一的一棵二叉树与之对应。所以本节研究的题目也可以转化成：n 个结点可以构建多少种形态不同的二叉树。

每一棵普通树对应的都是一棵没有右子树的二叉树，所以对于 n 个结点的树来说，树的形态改变是因为除了根结点之外的其它结点改变形态得到的，所以，n 个结点构建的形态不同的树与之对应的是 n-1 个结点构建的形态不同的二叉树。

如果 tn 表示 n 个结点构建的形态不同的树的数量，bn 表示 n 个结点构建的形态不同的二叉树的数量，则两者之间有这样的关系：`tn=bn-1`。

###### 方法一

最直接的一种方法就是推理。当 n=0 时，只能构建一棵空树；当 n=2 时，可以构建 2 棵形态不同的二叉树，如图1（A）；当 n=3 时，可以构建 5 棵形态互不相同的二叉树，如图 1（B）。

![img](http://data.biancheng.net/uploads/allimg/170905/2-1FZ5104043937.png)

<center>图 1 不同形态的二叉树</center>


对于具有 n（ n>1 ）个结点的二叉树来说，都可以看成是一个根结点、由 i 个结点组成的左子树和由 `n-i-1` 个结点组成的右子树。

> 当 n=1 时，也适用，只不过只有一个根结点，没有左右孩子（i=0）。

可以得出一个递推公式：
![img](http://data.biancheng.net/uploads/allimg/170905/2-1FZ5104141558.png)
通过对公式一步步的数学推算，最后得出，含有 n 个结点的不相似的二叉树的数量为：
![img](http://data.biancheng.net/uploads/allimg/170905/2-1FZ5104202Y5.png)

###### 方法二

从遍历二叉树的角度进行分析，对于任意一棵二叉树来说，它的前序序列和中序序列以及后序序列都是唯一的。其实是这句话还可以倒过来说，只要确定了一棵二叉树的三种遍历序列中的两种，那么这棵二叉树也可以唯一确定。

例如，给定了一个二叉树的前序序列和中序序列分别为：

前序序列：A B C D E F G
中序序列：C B E D A F G

可以唯一得到的二叉树如图 2（4）：

![img](http://data.biancheng.net/uploads/allimg/170905/2-1FZ510424EF.png)

<center>图 2 构造二叉树的过程示意图</center>


分析：通过前序序列得知，结点A为二叉树的根结点，结合中序序列，在结点 A 左侧的肯定为其左孩子中的所有结点，右边为右孩子的所有结点，如图 2（1）所示。

再分析 A 结点的左孩子，在前序序列看到，结点 A 后紧跟的是结点 B，由此断定结点 A 的左孩子是 B，再看中序序列，结点 B 左侧只有一个结点 C ，为 B 的左孩子，结点 B 右侧的结点E 和 D 为右孩子，如图 2（2）。

再分析结点 B 的右孩子，前序序列看到，结点 D 在 E 的前边，所有 D 为 B 的右孩子。在中序序列中，结点 E 在 D 前边，说明 E 是 D 的左孩子，如图 2（3）。

最后分析结点 A 的右孩子，由前序序列看到， F 在 G 前边，说明F为根结点。在中序序列中也是如此，说明，G 是 F 的右孩子。如图 2（4）所示。

如果要唯一确定一棵二叉树，必须知道至少两种遍历序列。如果只确定一种序列，无法准确判定二叉树的具体构造。

![img](http://data.biancheng.net/uploads/allimg/170905/2-1FZ51044001J.png)

<center>图 3 前序序列（1，2，3)的二叉树</center>


如图 3 所示为前序序列（1，2，3）构建的不同形态的二叉树，他们的中序序列各不相同。所以不同形态二叉树的数目恰好就是前序序列一定的情况下，所能得到的不同的中序序列的个数。

中序序列是对二叉树进行中序遍历获得的，遍历的过程实质上就是结点数据进[栈](http://data.biancheng.net/view/169.html)

出栈的过程。所以，中序序列的个数就是数列（1，2，3）按1-2-3的顺序进栈，
各元素选择在不同的时间点出栈，所获的的不同的出栈顺序即为中序序列，而中序序列的数目，也就是不同形态的二叉树的个数。

![img](http://data.biancheng.net/uploads/allimg/170905/2-1FZ510442J59.png)

<center>图 4 中序遍历时进栈和出栈的过程</center>


根据数列中数据的个数 n，所得到的排列顺序的数目为：
![img](http://data.biancheng.net/uploads/allimg/170905/2-1FZ5104510936.png)
通过以上两种方式，都可以知道n个结点能构建的不同形态的二叉树的数量，再结合 tn=bn-1，就可以计算出 n 个结点能构建的不同形态的树的个数。



#### 六 图

##### 6.1 什么是图存储结构 

我们知道，数据之间的关系有 3 种，分别是 "一对一"、"一对多" 和 "多对多"，前两种关系的数据可分别用[线性表](http://data.biancheng.net/view/157.html)和[树](http://data.biancheng.net/view/23.html)结构存储，本节学习存储具有"多对多"逻辑关系数据的结构——图存储结构。


![img](http://data.biancheng.net/uploads/allimg/190103/2-1Z1032054241T.gif)

<center>图 1 图存储结构示意图</center>

图 1 所示为存储 V1、V2、V3、V4 的图结构，从图中可以清楚的看出数据之间具有的"多对多"关系。例如，V1 与 V4 和 V2 建立着联系，V4 与 V1 和 V3 建立着联系，以此类推。

>有争议 此处 V1 与 V4 和 V2 建立着联系 应该为 V2 与 V4 与 V1 建立联系

与[链表](http://data.biancheng.net/view/160.html)不同，图中存储的各个数据元素被称为顶点（而不是节点）。拿图 1 来说，该图中含有 4 个顶点，分别为顶点 V1、V2、V3 和 V4。

> 图存储结构中，习惯上用 Vi 表示图中的顶点，且所有顶点构成的集合通常用 V 表示，如图 1 中顶点的集合为 V={V1,V2,V3,V4}。


注意，图 1 中的图仅是图存储结构的其中一种，数据之间 "多对多" 的关系还可能用如图 2 所示的图结构表示：


![img](http://data.biancheng.net/uploads/allimg/190103/2-1Z1032055151L.gif)

<center>图 2 有向图示意图</center>


可以看到，各个顶点之间的关系并不是"双向"的。比如，V4 只与 V1 存在联系（从 V4 可直接找到 V1），而与 V3 没有直接联系；同样，V3 只与 V4 存在联系（从 V3 可直接找到 V4），而与 V1 没有直接联系，以此类推。

因此，图存储结构可细分两种表现类型，分别为无向图（图 1）和有向图（图 2）。

###### 6.1.1 图的基本常识

- 弧头和弧尾

  有向图中，无箭头一端的顶点通常被称为"初始点"或"弧尾"，箭头直线的顶点被称为"终端点"或"弧头"。

- 入度和出度

  对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V 的入度（InDegree，记为 ID(V)）；箭头远离 V 的弧的数量为 V 的出度（OutDegree，记为OD(V)）。拿图 2 中的顶点 V1来说，该顶点的入度为 1，出度为 2（该顶点的度为 3）。

- (V1,V2) 和 <V1,V2> 的区别

  无向图中描述两顶点（V1 和 V2）之间的关系可以用 (V1,V2) 来表示，而有向图中描述从 V1 到 V2 的"单向"关系用 <V1,V2> 来表示。

  由于图存储结构中顶点之间的关系是用线来表示的，因此 (V1,V2) 还可以用来表示无向图中连接 V1 和 V2 的线，又称为边；同样，<V1,V2> 也可用来表示有向图中从 V1 到 V2 带方向的线，又称为弧。

- 集合 VR 的含义

  并且，图中习惯用 VR 表示图中所有顶点之间关系的集合。例如，图 1 中无向图的集合 VR={(v1,v2),(v1,v4),(v1,v3),(v3,v4)}，图 2 中有向图的集合 VR={<v1,v2>,<v1,v3>,<v3,v4>,<v4,v1>}。

- 路径和回路

  无论是无向图还是有向图，从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。如果路径中第一个顶点和最后一个顶点相同，则此路径称为"回路"（或"环"）。

  并且，若路径中各顶点都不重复，此路径又被称为"简单路径"；同样，若回路中的顶点互不重复，此回路被称为"简单回路"（或简单环）。

  拿图 1 来说，从 V1 存在一条路径还可以回到 V1，此路径为 {V1,V3,V4,V1}，这是一个回路（环），而且还是一个简单回路（简单环）。

  在有向图中，每条路径或回路都是有方向的。

- 权和网的含义

  在某些实际场景中，图中的每条边（或弧）会赋予一个实数来表示一定的含义，这种与边（或弧）相匹配的实数被称为"权"，而带权的图通常称为网。如图 3 所示，就是一个网结构：


![img](http://data.biancheng.net/uploads/allimg/190103/2-1Z10321001LT.gif)

<center>图 3 带权的图存储结构</center>


子图：指的是由图中一部分顶点和边构成的图，称为原图的子图。

###### 6.1.2 图存储结构的分类

根据不同的特征，图又可分为完全图，[连通图](http://data.biancheng.net/view/201.html)、稀疏图和稠密图：

- 完全图：若图中各个顶点都与除自身外的其他顶点有关系，这样的无向图称为完全图（如图 4a)）。同时，满足此条件的有向图则称为有向完全图（图 4b)）。


  ![img](http://data.biancheng.net/uploads/allimg/190103/2-1Z103210110O8.gif)

  <center>图 4 完全图示意图</center>

  > 具有 n 个顶点的完全图，图中边的数量为 n(n-1)/2；而对于具有 n 个顶点的有向完全图，图中弧的数量为 n(n-1)。

- 稀疏图和稠密图：这两种图是相对存在的，即如果图中具有很少的边（或弧），此图就称为"稀疏图"；反之，则称此图为"稠密图"。

  > 稀疏和稠密的判断条件是：e<nlogn，其中 e 表示图中边（或弧）的数量，n 表示图中顶点的数量。如果式子成立，则为稀疏图；反之为稠密图。


有关连通图的相关知识，后续专门有一篇文章做详细介绍。

##### 6.2 什么是连通图

前面讲过，图中从一个顶点到达另一顶点，若存在至少一条路径，则称这两个顶点是连通着的。例如图 1 中，虽然 V1 和 V3 没有直接关联，但从 V1 到 V3 存在两条路径，分别是 `V1-V2-V3` 和 `V1-V4-V3`，因此称 V1 和 V3 之间是连通的。


![顶点之间的连通状态示意图](http://data.biancheng.net/uploads/allimg/190105/2-1Z105093324193.gif)

<center>图 1 顶点之间的连通状态示意图</center>


无向图中，如果任意两个顶点之间都能够连通，则称此无向图为连通图。例如，图 2 中的无向图就是一个连通图，因为此图中任意两顶点之间都是连通的。


![连通图示意图](http://data.biancheng.net/uploads/allimg/190103/2-1Z1032054241T.gif)

<center>图 2 连通图示意图</center>


若无向图不是连通图，但图中存储某个子图符合连通图的性质，则称该子图为连通分量。

前面讲过，由图中部分顶点和边构成的图为该图的一个子图，但这里的子图指的是图中"最大"的连通子图（也称"极大连通子图"）。

如图 3 所示，虽然图 3a) 中的无向图不是连通图，但可以将其分解为 3 个"最大子图"（图 3b)），它们都满足连通图的性质，因此都是连通分量。


![连通分量示意图](http://data.biancheng.net/uploads/allimg/190105/2-1Z1050933411G.gif)

<center>图 3 连通分量示意图</center>

提示，图 3a) 中的无向图只能分解为 3 部分各自连通的"最大子图"。

需要注意的是，连通分量的提出是以"整个无向图不是连通图"为前提的，因为如果无向图是连通图，则其无法分解出多个最大连通子图，因为图中所有的顶点之间都是连通的。

###### 6.2.1 强连通图

有向图中，若任意两个顶点 Vi 和 Vj，满足从 Vi 到 Vj 以及从 Vj 到 Vi 都连通，也就是都含有至少一条通路，则称此有向图为强连通图。如图 4 所示就是一个强连通图。


![强连通图](http://data.biancheng.net/uploads/allimg/190105/2-1Z105093445450.gif)

<center>图 4 强连通图</center>


与此同时，若有向图本身不是强连通图，但其包含的最大连通子图具有强连通图的性质，则称该子图为强连通分量。


![强连通分量](http://data.biancheng.net/uploads/allimg/190105/2-1Z1050935002U.gif)

<center>图 5 强连通分量</center>


如图 5 所示，整个有向图虽不是强连通图，但其含有两个强连通分量。

###### 6.2.2 总结

可以这样说，**连通图是在无向图的基础上对图中顶点之间的连通做了更高的要求，而强连通图是在有向图的基础上对图中顶点的连通做了更高的要求。**



##### 6.3 生成树

在学习[连通图](http://data.biancheng.net/view/201.html)的基础上，本节学习什么是生成[树](http://data.biancheng.net/view/23.html)，以及什么是生成森林。

对连通[图](http://data.biancheng.net/view/200.html)进行遍历，过程中所经过的边和顶点的组合可看做是一棵普通树，通常称为生成树。


![连通图及其对应的生成树](http://data.biancheng.net/uploads/allimg/190106/2-1Z106101951H4.gif)

<center>图 1 连通图及其对应的生成树</center>


如图 1 所示，图 1a) 是一张连通图，图 1b) 是其对应的 2 种生成树。

连通图中，由于任意两顶点之间可能含有多条通路，遍历连通图的方式有多种，往往一张连通图可能有多种不同的生成树与之对应。

连通图中的生成树必须满足以下 2 个条件：

1. 包含连通图中所有的顶点；
2. 任意两顶点之间有且仅有一条通路；


因此，连通图的生成树具有这样的特征，即生成树中`边的数量 = 顶点数 - 1`。

###### 6.3.1 生成森林

生成树是对应连通图来说，而生成森林是对应非连通图来说的。

我们知道，非连通图可分解为多个连通分量，而每个连通分量又各自对应多个生成树（至少是 1 棵），因此与整个非连通图相对应的，是由多棵生成树组成的生成森林。


![非连通图和连通分量](http://data.biancheng.net/uploads/allimg/190105/2-1Z1050933411G.gif)

<center>图 2 非连通图和连通分量</center>


如图 2 所示，这是一张非连通图，可分解为 3 个连通分量，其中各个连通分量对应的生成树如图 3 所示：


![生成森林](http://data.biancheng.net/uploads/allimg/190106/2-1Z106102110P7.gif)

<center>图 3 生成森林</center>

注意，图 3 中列出的仅是各个连通分量的其中一种生成树。

因此，多个连通分量对应的多棵生成树就构成了整个非连通图的生成森林。



##### 6.4 图的存储 (待补充)

> http://data.biancheng.net/view/37.html

顺序 邻接 十字链表 邻接多重表

##### 6.5  深度优先与广度优先搜索

###### 6.5.1  深度优先搜索(DFS)

![img](http://data.biancheng.net/uploads/allimg/170905/2-1FZ51I14M57.png)

<center>图 1 无向图</center>


深度优先搜索的过程类似于[树](http://data.biancheng.net/view/23.html)的先序遍历，首先从例子中体会深度优先搜索。例如图 1 是一个无向图，采用深度优先算法遍历这个图的过程为：

1. 首先任意找一个未被遍历过的顶点，例如从 V1 开始，由于 V1 率先访问过了，所以，需要标记 V1 的状态为访问过；
2. 然后遍历 V1 的邻接点，例如访问 V2 ，并做标记，然后访问 V2 的邻接点，例如 V4 （做标记），然后 V8 ，然后 V5 ；
3. 当继续遍历 V5 的邻接点时，根据之前做的标记显示，所有邻接点都被访问过了。此时，从 V5 回退到 V8 ，看 V8 是否有未被访问过的邻接点，如果没有，继续回退到 V4 ， V2 ， V1 ；
4. 通过查看 V1 ，找到一个未被访问过的顶点 V3 ，继续遍历，然后访问 V3 邻接点 V6 ，然后 V7 ；
5. 由于 V7 没有未被访问的邻接点，所有回退到 V6 ，继续回退至 V3 ，最后到达 V1 ，发现没有未被访问的；
6. 最后一步需要判断是否所有顶点都被访问，如果还有没被访问的，以未被访问的顶点为第一个顶点，继续依照上边的方式进行遍历。


根据上边的过程，可以得到图 1 通过深度优先搜索获得的顶点的遍历次序为：

> V1 -> V2 -> V4 -> V8 -> V5 -> V3 -> V6 -> V7


所谓深度优先搜索，是从图中的一个顶点出发，每次遍历当前访问顶点的临界点，一直到访问的顶点没有未被访问过的临界点为止。然后采用依次回退的方式，查看来的路上每一个顶点是否有其它未被访问的临界点。访问完成后，判断图中的顶点是否已经全部遍历完成，如果没有，以未访问的顶点为起始点，重复上述过程。

> 深度优先搜索是一个不断回溯的过程。

###### 6.5.2 广度优先搜索 

广度优先搜索类似于树的层次遍历。从图中的某一顶点出发，遍历每一个顶点时，依次遍历其所有的邻接点，然后再从这些邻接点出发，同样依次访问它们的邻接点。按照此过程，直到图中所有被访问过的顶点的邻接点都被访问到。

最后还需要做的操作就是查看图中是否存在尚未被访问的顶点，若有，则以该顶点为起始点，重复上述遍历的过程。

还拿图 1 中的无向图为例，假设 V1 作为起始点，遍历其所有的邻接点 V2 和 V3 ，以 V2 为起始点，访问邻接点 V4 和 V5 ，以 V3 为起始点，访问邻接点 V6 、 V7 ，以 V4 为起始点访问 V8 ，以 V5 为起始点，由于 V5 所有的起始点已经全部被访问，所有直接略过， V6 和 V7 也是如此。
以 V1 为起始点的遍历过程结束后，判断图中是否还有未被访问的点，由于图 1 中没有了，所以整个图遍历结束。遍历顶点的顺序为：

> V1 -> V2 -> v3 -> V4 -> V5 -> V6 -> V7 -> V8


广度优先搜索的实现需要借助[队列](http://data.biancheng.net/view/172.html)

###### 6.5.3 总结 

本节介绍了两种遍历图的方式：深度优先搜索算法和广度优先搜索算法。深度优先搜索算法的实现运用的主要是回溯法，类似于树的先序遍历算法。广度优先搜索算法借助队列的先进先出的特点，类似于树的层次遍历。

##### 6.6 深度优先生成树和 广度优先生成树 

本章的第一节中，介绍了有关[生成树](http://data.biancheng.net/view/202.html)和生成森林的有关知识，本节来解决对于给定的无向[图](http://data.biancheng.net/view/200.html)，如何构建它们相对应的生成[树](http://data.biancheng.net/view/23.html)或者生成森林。

其实在对无向图进行遍历的时候，遍历过程中所经历过的图中的顶点和边的组合，就是图的生成树或者生成森林。

![img](http://data.biancheng.net/uploads/allimg/170912/2-1F912163410958.png)

<center>图 1 无向图</center>

例如，图 1 中的无向图是由 V1～V7 的顶点和编号分别为 a～i 的边组成。当使用[深度优先搜索](http://data.biancheng.net/view/39.html)

算法时，假设 V1 作为遍历的起始点，涉及到的顶点和边的遍历顺序为（不唯一）：
![img](http://data.biancheng.net/uploads/allimg/170912/2-1F912163444395.png)

此种遍历顺序构建的生成树为：

![img](http://data.biancheng.net/uploads/allimg/170912/2-1F912163502E8.png)

<center>图 2 深度优先生成树</center>


由深度优先搜索得到的树为深度优先生成树。同理，[广度优先搜索](http://data.biancheng.net/view/39.html)生成的树为广度优先生成树，图 1 无向图以顶点 V1 为起始点进行广度优先搜索遍历得到的树，如图 3 所示：

![img](http://data.biancheng.net/uploads/allimg/170912/2-1F912163551311.png)

<center>图 3 广度优先生成树</center>

###### 6.6.1 非[连通图](http://data.biancheng.net/view/201.html)的生成森林

非连通图在进行遍历时，实则是对非连通图中每个连通分量分别进行遍历，在遍历过程经过的每个顶点和边，就构成了每个连通分量的生成树。

非连通图中，多个连通分量构成的多个生成树为非连通图的生成森林。

###### 6.6.2 深度优先生成森林

![img](http://data.biancheng.net/uploads/allimg/170912/2-1F912163A4559.png)

<center>图 4 深度优先生成森林</center>


例如，对图 4 中的非连通图 （a） 采用深度优先搜索算法遍历时，得到的深度优先生成森林（由 3 个深度优先生成树构成）如 （b） 所示（不唯一）。

> 非连通图在遍历生成森林时，可以采用[孩子兄弟表示法](http://data.biancheng.net/view/198.html)将森林转化为一整棵二叉树进行存储。

运行程序，拿图 4（a）中的非连通图为例，构建的深度优先生成森林，使用孩子兄弟表示法表示为：

![img](http://data.biancheng.net/uploads/allimg/170912/2-1F912163P2F9.png)

<center>图5 孩子兄弟表示法表示深度优先生成森林</center>

> 图中，3 种颜色的树各代表一棵深度优先生成树，使用孩子兄弟表示法表示，也就是将三棵树的树根相连，第一棵树的树根作为整棵树的树根。

###### 6.6.3 广度优先生成森林

非连通图采用广度优先搜索算法进行遍历时，经过的顶点以及边的集合为该图的广度优先生成森林。

拿图 4（a）中的非连通图为例，通过广度优先搜索得到的广度优先生成森林用孩子兄弟表示法为：

![img](http://data.biancheng.net/uploads/allimg/170912/2-1F912163U9C6.png)

<center>图6 广度优先生成森林（孩子兄弟表示法)</center>



##### 6.7 普里姆算法(Prim) 最小生成树

通过前面的学习，对于含有 n 个顶点的[连通图](http://data.biancheng.net/view/201.html)来说可能包含有多种[生成树](http://data.biancheng.net/view/202.html)，例如图1 所示：


![img](http://data.biancheng.net/uploads/allimg/170911/2-1F911161130950.png)

<center>图 1 连通图的生成树</center>

图 1 中的连通图和它相对应的生成树，可以用于解决实际生活中的问题：假设A、B、C 和 D 为 4 座城市，为了方便生产生活，要为这 4 座城市建立通信。对于 4 个城市来讲，本着节约经费的原则，只需要建立 3 个通信线路即可，就如图 1（b）中的任意一种方式。

在具体选择采用（b）中哪一种方式时，需要综合考虑城市之间间隔的距离，建设通信线路的难度等各种因素，将这些因素综合起来用一个数值表示，当作这条线路的权值。

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F911161350260.png)

<center>图 2 无向网</center>


假设通过综合分析，城市之间的权值如图 2（a）所示，对于（b）的方案中，选择权值总和为 7 的两种方案最节约经费。

这就是本节要讨论的最小生成树的问题，简单得理解就是给定一个带有权值的连通图（连通网），如何从众多的生成树中筛选出权值总和最小的生成树，即为该图的最小生成树。

给定一个连通网，求最小生成树的方法有：普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法。

###### 6.7.1 普里姆算法

普里姆算法在找最小生成树时，将顶点分为两类，一类是在查找的过程中已经包含在树中的（假设为 A 类），剩下的是另一类（假设为 B 类）。

对于给定的连通网，起始状态全部顶点都归为 B 类。在找最小生成树时，选定任意一个顶点作为起始点，并将之从 B 类移至 A 类；然后找出 B 类中到 A 类中的顶点之间权值最小的顶点，将之从 B 类移至 A 类，如此重复，直到 B 类中没有顶点为止。所走过的顶点和边就是该连通图的最小生成树。

例如，通过普里姆算法查找图 2（a）的最小生成树的步骤为：

假如从顶点A出发，顶点 B、C、D 到顶点 A 的权值分别为 2、4、2，所以，对于顶点 A 来说，顶点 B 和顶点 D 到 A 的权值最小，假设先找到的顶点 B：

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F911161I4302.png)


继续分析顶点 C 和 D，顶点 C 到 B 的权值为 3，到 A 的权值为 4；顶点 D 到 A 的权值为 2，到 B 的权值为无穷大（如果之间没有直接通路，设定权值为无穷大）。所以顶点 D 到 A 的权值最小：

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F911161S35D.png)


最后，只剩下顶点 C，到 A 的权值为 4，到 B 的权值和到 D 的权值一样大，为 3。所以该连通图有两个最小生成树：



![img](http://data.biancheng.net/uploads/allimg/170911/2-1F911161910B7.png)

普里姆算法的运行效率只与连通网中包含的顶点数相关，而和网所含的边数无关。所以普里姆算法适合于解决边稠密的网，该算法运行的时间复杂度为：`O(n2)`。

> 如果连通网中所含边的绸密度不高，则建议使用克鲁斯卡尔算法求最小生成树（下节详细介绍）。



##### 6.8 克鲁斯卡尔算法(Kruskal算法)求最小生成树

上一节介绍了求最小[生成树](http://data.biancheng.net/view/202.html)之普里姆算法。该算法从顶点的角度为出发点，时间复杂度为`O(n2)`，更适合与解决边的绸密度更高的连通网。

本节所介绍的克鲁斯卡尔算法，从边的角度求网的最小生成[树](http://data.biancheng.net/view/23.html)，时间复杂度为`O(eloge)`。和普里姆算法恰恰相反，更适合于求边稀疏的网的最小生成树。

对于任意一个连通网的最小生成树来说，在要求总的权值最小的情况下，最直接的想法就是将连通网中的所有边按照权值大小进行升序排序，从小到大依次选择。

由于最小生成树本身是一棵生成树，所以需要时刻满足以下两点：

- 生成树中任意顶点之间有且仅有一条通路，也就是说，生成树中不能存在回路；
- 对于具有 n 个顶点的连通网，其生成树中只能有 n-1 条边，这 n-1 条边连通着 n 个顶点。

> 连接 n 个顶点在不产生回路的情况下，只需要 n-1 条边。

所以克鲁斯卡尔算法的具体思路是：将所有边按照权值的大小进行升序排序，然后从小到大一一判断，条件为：如果这个边不会与之前选择的所有边组成回路，就可以作为最小生成树的一部分；反之，舍去。直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。筛选出来的边和所有的顶点构成此连通网的最小生成树。

> 判断是否会产生回路的方法为：在初始状态下给每个顶点赋予不同的标记，对于遍历过程的每条边，其都有两个顶点，判断这两个顶点的标记是否一致，如果一致，说明它们本身就处在一棵树中，如果继续连接就会产生回路；如果不一致，说明它们之间还没有任何关系，可以连接。

假设遍历到一条由顶点 A 和 B 构成的边，而顶点 A 和顶点 B 标记不同，此时不仅需要将顶点 A 的标记更新为顶点 B 的标记，还需要更改所有和顶点 A 标记相同的顶点的标记，全部改为顶点 B 的标记。

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F911163R01W.png)

<center>图 1 连通网</center>

例如，使用克鲁斯卡尔算法找图 1 的最小生成树的过程为：

首先，在初始状态下，对各顶点赋予不同的标记（用颜色区别），如下图所示：

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F91116422K37.png)

<center>（1)</center>

对所有边按照权值的大小进行排序，按照从小到大的顺序进行判断，首先是（1，3），由于顶点 1 和顶点 3 标记不同，所以可以构成生成树的一部分，遍历所有顶点，将与顶点 3 标记相同的全部更改为顶点 1 的标记，如（2）所示：

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F911163922M6.png)

<center>（2)</center>

其次是（4，6）边，两顶点标记不同，所以可以构成生成树的一部分，更新所有顶点的标记为：

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F91116431A11.png)

<center>（3)</center>

其次是（2，5）边，两顶点标记不同，可以构成生成树的一部分，更新所有顶点的标记为：

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F911164335108.png)

<center>（4)</center>


然后最小的是（3，6）边，两者标记不同，可以连接，遍历所有顶点，将与顶点 6 标记相同的所有顶点的标记更改为顶点 1 的标记：

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F91116435D40.png)

<center>（5)</center>

继续选择权值最小的边，此时会发现，权值为 5 的边有 3 个，其中（1，4）和（3，4）各自两顶点的标记一样，如果连接会产生回路，所以舍去，而（2，3）标记不一样，可以选择，将所有与顶点 2 标记相同的顶点的标记全部改为同顶点 3 相同的标记：

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F91116442R29.png)

<center>（6)</center>


当选取的边的数量相比与顶点的数量小 1 时，说明最小生成树已经生成。所以最终采用克鲁斯卡尔算法得到的最小生成树为（6）所示。

##### 6.9 重连通图及重连通分量

在无向[图](http://data.biancheng.net/view/200.html)中，如果任意两个顶点之间含有不止一条通路，这个图就被称为重[连通图](http://data.biancheng.net/view/201.html)。在重连通图中，在删除某个顶点及该顶点相关的边后，图中各顶点之间的连通性也不会被破坏。

在一个无向图中，如果删除某个顶点及其相关联的边后，原来的图被分割为两个及以上的连通分量，则称该顶点为无向图中的一个关节点（或者“割点”）。

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F9111F216335.png)

<center>图 1 连通图</center>

图 1 是连通图但不是重连通图，图中有4个关节点，分别是：A、B、D 和 G。比如删除顶点 B 及相关联的边后，原图就变为：

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F9111F253129.png)

<center>图 2 连通分量</center>

可以看到，图被分割为各自独立的 3 部分，顶点集合分别为：{A、C、F、L、M、J}、{G、H、I、K} 和 {D、E}。

了解了什么是关节点后，重连通图其实就是没有关节点的连通图。

在重连通图中，只删除一个顶点及其相关联的边，肯定不会破坏其连通性。如果一味地做删除顶点的操作，直到删除 K 个顶点及其关联的边后，图的连通性才遭到破坏，则称此重连通图的连通度为 K 。

###### 6.9.1 重连通图的实际应用

如今的通信网络对人们的生活有着重要的影响，如果将通信网络比做一个巨大的连通图的话，它的连通度 K 值越高，证明其稳定性越好，即使某一个站点发生故障无法工作也不会影响整个系统的正常工作。

同样，小到城市之间，大到国家之间的航空网也可以看作是一个连通图，但如果此图建设成为重连通图，当某条航线因为天气等因素关闭时，飞机仍可以从别的航线到达目的地。

在战争中，有“兵马未动，粮草先行”的说法，可见后勤补给对军队的重要性。如果补给线是一个重连通图，就不用过于担心补给线被破坏的问题，因为即使破坏一条，还有其它的，只要连通度足够大。

###### 6.9.2 判断重连通图的方法

了解了什么是重连通图之后，如何编写程序直接判断一个图是否是重连通图呢？

对于任意一个连通图来说，都可以通过[深度优先搜索](http://data.biancheng.net/view/39.html)算法获得一棵[深度优先生成树](http://data.biancheng.net/view/45.html)，例如，图 1 通过深度优先搜索获得的深度优先[生成树](http://data.biancheng.net/view/202.html)为：

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F9111F601611.png)

<center>图 3 深度优先生成树</center>


虚线表示遍历生成树时未用到的边，简称“回边”。也就是图中有，但是遍历时没有用到，生成树中用虚线表示出来。

在深度优先生成树中，图中的关节点有两种特性：

1. 首先判断整棵树的树根结点，如果树根有两条或者两条以上的子树，则该顶点肯定是关节点。因为一旦树根丢失，生成树就会变成森林。
2. 然后判断生成树中的每个非叶子结点，以该结点为根结点的每棵子树中如果有结点的回边与此非叶子结点的祖宗结点相关联，那么此非叶子结点就不是关节点；反之，就是关节点。

> 注意：必须是和该非叶子结点的祖宗结点（不包括结点本身）相关联，才说明此结点不是关节点。


所以，判断一个图是否是重连通图，也可以转变为：判断图中是否有关节点，如果没有关节点，证明此图为重连通图；反之则不是。

拿图 3 的生成树来说，利用两个特性判断每个顶点是否为关节点：

- 首先，判断树根结点 A ，由于有两个孩子，也就是有两棵子树，所以 A 是关节点。然后判断树中所有的非叶子结点，也就是： L 、 M 、 B 、 D 、 H 、 K 、 G ；
- L 结点为根结点的子树中 B 结点有回边直接关联 A ，所以， L 不是关节点；
- 在以 M 结点为树根的子树中，J 结点和 B 结点都有回边关联 M 结点的祖宗结点，所以，M 不是关节点；
- 以 B 结点为根结点的 3 棵子树中，只有一棵子树（只包含结点 C ）与 B 结点的祖宗结点 A 有关联，其他两棵子树没有，所以结点 B 是关节点；
- 以 D 结点为根结点的子树中只有结点 E，且没有回边与祖宗结点关联，所以，D 是关节点；
- 以 H 结点为根结点的子树中， G 结点与 B 结点关联，所以， H 结点不是关节点；
- K 结点和 H 结点相同，由于 G 结点与祖宗结点 B 关联，所以 K 结点不是关节点；
- 以 G 结点为根结点的子树中只有一个结点 I，没有回边，所以结点 G 是关节点；


综上所述，图 3 中的关节点有 4 个，分别是： A 、 B 、 D 、 G 



##### 6.10 拓扑排序算法

拓扑排序指的是将有向无环[图](http://data.biancheng.net/view/200.html)（又称“DAG”图）中的顶点按照图中指定的先后顺序进行排序。

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F9111G254232.png)

<center>图 1 有向无环图</center>

例如，图 1 中的两个图都是有向无环图，都可以使用拓扑排序对图中的顶点进行排序，两个图形的区别是：左图中的 V2 和 V3 之间没有明确的前后顺序；而右图中任意两个顶点之间都有前后顺序。


所以，左图中顶点之间的关系被称为“偏序”关系；右图中顶点之间的关系被称为”全序“关系。

在有向无环图中，弧的方向代表着顶点之间的先后次序，例如从 V1 指向 V2 的弧表示在进行排序时 V1 在前， V2 在后。

> 全序是偏序的一种特殊情况。对于任意一个有向无环图来说，通过拓扑排序得到的序列首先一定是偏序，如果任意两个顶点都具有前后顺序，那么此序列是全序。

###### 6.10.1 拓扑排序的方法

对有向无环图进行拓扑排序，只需要遵循两个原则：

1. 在图中选择一个没有前驱的顶点 V；
2. 从图中删除顶点 V 和所有以该顶点为尾的弧。


例如，在对图 1 中的左图进行拓扑排序时的步骤如图 2 所示：

![img](http://data.biancheng.net/uploads/allimg/170911/2-1F9111G640192.png)

<center>图 2 拓扑排序</center>


有向无环图如果顶点本身具有某种实际意义，例如用有向无环图表示大学期间所学习的全部课程，每个顶点都表示一门课程，有向边表示课程学习的先后次序，例如要先学《程序设计基础》和《离散数学》，然后才能学习《数据结构》。所以用来表示某种活动间的优先关系的有向图简称为“AOV网”。

进行拓扑排序时，首先找到没有前驱的顶点 V1，如图 2（1）所示；在删除顶点 V1 及以 V1 作为起点的弧后，继续查找没有前驱的顶点，此时， V2 和 V3 都符合条件，可以随机选择一个，例如图 2（2） 所示，选择 V2 ，然后继续重复以上的操作，直至最后找不到没有前驱的顶点。

所以，针对图 2 来说，拓扑排序最后得到的序列有两种：

- V1 -> V2 -> V3 -> V4
- V1 -> V3 -> V2 -> V4

如果顶点之间只是具有偏序关系，那么拓扑排序的结果肯定不唯一；如果顶点之间是全序关系，那么拓扑排序得到的序列唯一。

###### 6.10.2 拓扑排序的C语言实现

在编写程序解决拓扑排序的问题时，大致思路为：首先通过[邻接表](http://data.biancheng.net/view/203.html)

将 AOV 网进行存储，由于拓扑排序的整个过程中，都是以顶点的入度为依据进行排序，所以需要根据建立的邻接表统计出各顶点的入度。

在得到各顶点的入度后，首先找到入度为 0 的顶点作为拓扑排序的起始点，然后查找以该顶点为起始点的所有顶点，如果入度为 1，说明如果删除前一个顶点后，该顶点的入度为 0，为拓扑排序的下一个对象。



##### 6.11 关键路径 

在学习拓扑排序一节时讲到拓扑排序只适用于 AOV 网，本节所介绍的求关键路径针对的是和 AOV 网相近的 AOE 网。

###### 6.11.1 AOE网

AOE 网是在 AOV 网的基础上，其中每一个边都具有各自的权值，是一个有向无环网。其中权值表示活动持续的时间。

![img](http://data.biancheng.net/uploads/allimg/170912/2-1F912154422b1.png)

<center>图 1 AOE网</center>

如图 1 所示就是一个 AOE 网，例如 a1=6 表示完成 a1 活动完成需要 6 天；AOE 网中每个顶点表示在它之前的活动已经完成，可以开始后边的活动，例如 V5 表示 a4 和 a5 活动已经完成，a7 和 a8 可以开始。

使用 AOE 网可以帮助解决这样的问题：如果将 AOE 网看做整个项目，那么完成整个项目至少需要多少时间？

解决这个问题的关键在于从 AOE 网中找到一条从起始点到结束点长度最长的路径，这样就能保证所有的活动在结束之前都能完成。

> 起始点是入度为 0 的点，称为“源点”；结束点是出度为 0 的点，称为“汇点”。这条最长的路径，被称为”关键路径“。

###### 6.11.2 关键路径

为了求出一个给定 AOE 网的关键路径，需要知道以下 4 个统计数据：

- 对于 AOE 网中的顶点有两个时间：最早发生时间（用 Ve(j) 表示）和最晚发生时间（用 Vl(j) 表示）；
- 对于边来说，也有两个时间：最早开始时间（用 e(i) 表示）和最晚开始时间（ l(i) 表示）。


Ve(j)：对于 AOE 网中的任意一个顶点来说，从源点到该点的最长路径代表着该顶点的最早发生时间，通常用 Ve(j) 表示。

例如，图 1 中从 V1 到 V5 有两条路径，V1 作为源点开始后，a1 和 a2 同时开始活动，但由于 a1 和 a2 活动的时间长度不同，最终 V1-V3-V5 的这条路径率先完成。但是并不是说 V5 之后的活动就可以开始，而是需要等待 V1-V2-V5 这条路径也完成之后才能开始。所以对于 V5 来讲，Ve(5) = 7。


Vl(j)：表示在不推迟整个工期的前提下，事件 Vk 允许的最晚发生时间。

例如，图 1 中，在得知整个工期完成的时间是 18 天的前提下，V7 最晚要在第 16 天的时候开始，因为 a10 活动至少需要 2 天时间才能完成，如果在 V7 事件在推迟，就会拖延整个工期。所以，对于 V7 来说，它的 Vl(7)=16。


e(i)：表示活动 ai 的最早开始时间，如果活动 ai 是由弧 <Vk,Vj> 表示的，那么活动 ai 的最早开始的时间就等于时间 Vk 的最早发生时间，也就是说：e[i] = ve[k]。

e(i)很好理解，拿图 1 中 a4 来说，如果 a4 想要开始活动，那么首先前提就是 V2 事件开始。所以 e[4]=ve[2]。


l(i)：表示活动 ai 的最晚开始时间，如果活动 ai 是由弧 <Vk,Vj> 表示，ai 的最晚开始时间的设定要保证 Vj 的最晚发生时间不拖后。所以，l[i]=Vl[j]-len<Vk,Vj>。

在得知以上四种统计数据后，就可以直接求得 AOE 网中关键路径上的所有的关键活动，方法是：对于所有的边来说，如果它的最早开始时间等于最晚开始时间，称这条边所代表的活动为关键活动。由关键活动构成的路径为关键路径。

###### 6.11.3 求关键路径的具体过程

对图 1 中的 AOE 图求关键路径，首先完成 Ve(j)、Vl(j)、e(i)、l(i) 4 种统计信息的准备工作。

Ve(j)，求出从源点到各顶点的最长路径长度为（长度最大的）：

![img](http://data.biancheng.net/uploads/allimg/170912/2-1F91215503aH.png)

Vl(j)，求出各顶点的最晚发生时间（从后往前推，多种情况下选择最小的）：

![img](http://data.biancheng.net/uploads/allimg/170912/2-1F912155103423.png)

e(i)，求出各边中ai活动的最早开始时间：

![img](http://data.biancheng.net/uploads/allimg/170912/2-1F91215511SY.png)

l(i),求各边中ai活动的最晚开始时间（多种情况下，选择最小的）：

![img](http://data.biancheng.net/uploads/allimg/170912/2-1F912155132560.png)

通过对比 l(i) 和 e(i) ，其中 a1 、 a4 、 a7 、 a8 、 a10 、 a11 的值都各自相同，所以，在图 1 中的 AOE 网中有两条关键路径：

![img](http://data.biancheng.net/uploads/allimg/170912/2-1F912155150E8.png)

<center>图 2 关键路径</center>



##### 6.12 迪杰斯特拉算法

如今出行已经不需要再为找不着路而担心了，车上有车载导航，手机中有导航App。只需要确定起点和终点，导航会自动规划出可行的距离最短的道路。这是最短路径在人们实际生活中最典型的应用。

在一个网（有权[图](http://data.biancheng.net/view/200.html)）中，求一个顶点到另一个顶点的最短路径的计算方式有两种：迪杰斯特拉（Dijkstra算法）和弗洛伊德（Floyd）算法。迪杰斯特拉算法计算的是有向网中的某个顶点到其余所有顶点的最短路径；弗洛伊德算法计算的是任意两顶点之间的最短路径。

> 最短路径算法既适用于有向网，也同样适用于无向网。本节将围绕有向网讲解迪杰斯特拉算法的具体实现。

###### 6.12.1 迪杰斯特拉（Dijkstra算法）

迪杰斯特拉算法计算的是从网中一个顶点到其它顶点之间的最短路径问题。

![img](http://data.biancheng.net/uploads/allimg/170922/2-1F922163925J8.png)



<center>图 1 带权有向图</center>


如图 1 所示是一个有向网，在计算 V0 到其它所有顶点之间的最小路径时，迪杰斯特拉算法的计算方式为：

从 V0 出发，由于可以直接到达 V2 和 V5 ，而其它顶点和 V0 之间没有弧的存在，所以之间的距离设定为无穷大，可以得到下面这个表格：

![img](http://data.biancheng.net/uploads/allimg/170922/2-1F922164041616.png)

从表格中可以看到，V0 到 V2 的距离最近，所以迪杰斯特拉算法设定 V0-V2 为 V0 到 V2 之间的最短路径，最短路径的权值和为 10。

已经判断 V0-V2 是最短路径，所以以 V2 为起始点，判断 V2 到除了 V0 以外的其余各点之间的距离，如果对应的权值比前一张表格中记录的数值小，就说明网中有一条更短的路径，直接更新表格；反之表格中的数据不变。可以得到下面这个表格：

![img](http://data.biancheng.net/uploads/allimg/171127/2-1G12G53335193.png)

例如，表格中 V0 到 V3 的距离，发现当通过 V2 到达 V3 的距离比之前的 ∞ 要小，所以更新表格。

更新之后，发现 V0-V4 的距离最近，设定 V0 到 V4 的最短路径的值为 30。之后从 V4 出发，判断到未确定最短路径的其它顶点的距离，继续更新表格：

![img](http://data.biancheng.net/uploads/allimg/170922/2-1F922164233D0.png)

更新后确定从 V0 到 V3 的最短路径为 V0-V4-V3，权值为 50。然后从 V3 出发，继续判断：

![img](http://data.biancheng.net/uploads/allimg/170922/2-1F922164254b9.png)

对于 V5 来说，通过 V0-V4-V3-V5 的路径要比之前的权值 90 还要小，所以更新表格，更新后可以看到，V0-V5 的距离此时最短，可以确定 V0 到 V5 的最短路径为 60。

最后确定 V0-V1 的最短路径，由于从 V0 无法到达 V1 ，最终设定 V0 到 V1 的最短路径为 ∞（无穷大）。

在确定了 V0 与其他所有顶点的最短路径后，迪杰斯特拉算法才算结束。

事例中借用了图 1 的有向网对迪杰斯特拉算法进行了讲解，实际上无向网中的最短路径问题也可以使用迪杰斯特拉算法解决，解决过程和上述过程完全一致。

###### 6.12.2 总结

迪杰斯特拉算法解决的是从网中的一个顶点到所有其它顶点之间的最短路径，算法整体的时间复杂度

为`O(n2)`。但是如果需要求任意两顶点之间的最短路径，使用迪杰斯特拉算法虽然最终虽然也能解决问题，但是大材小用，相比之下使用弗洛伊德算法解决此类问题会更合适。

> 弗洛伊德算法实现的具体过程下一节会作详细介绍。



##### 6.13 弗洛伊德算法

通过前一节对迪杰斯特拉算法的学习，主要解决从网（带权[图](http://data.biancheng.net/view/200.html)）中某一顶点计算到其它顶点之间的最短路径问题。如果求有向网中每一对顶点之间的最短路径，使用迪杰斯特拉算法的解决思路是：以每一个顶点为源点，执行迪杰斯特拉算法。这样可以求得每一对顶点之间的最短路径。

本节介绍另外一种解决算法:弗洛伊德算法，该算法相比于使用迪杰斯特拉算法在解决此问题上的时间复杂度

虽然相同，都为`O(n3)`，但是弗洛伊德算法的实现形式更简单。

###### 6.13.1 弗洛伊德算法

弗洛伊德的核心思想是：对于网中的任意两个顶点（例如顶点 A 到顶点 B）来说，之间的最短路径不外乎有 2 种情况：



1. 直接从顶点 A 到顶点 B 的弧的权值为顶点 A 到顶点 B 的最短路径；
2. 从顶点 A 开始，经过若干个顶点，最终达到顶点 B，期间经过的弧的权值和为顶点 A 到顶点 B 的最短路径。


所以，弗洛伊德算法的核心为：对于从顶点 A 到顶点 B 的最短路径，拿出网中所有的顶点进行如下判断：

Dis（A，K）+ Dis（K，B）< Dis（A，B）

其中，K 表示网中所有的顶点；Dis（A，B） 表示顶点 A 到顶点 B 的距离。

也就是说，拿出所有的顶点 K，判断经过顶点 K 是否存在一条可行路径比直达的路径的权值小，如果式子成立，说明确实存在一条权值更小的路径，此时只需要更新记录的权值和即可。

任意的两个顶点全部做以上的判断，最终遍历完成后记录的最终的权值即为对应顶点之间的最短路径。

###### 6.13.2 完整实例

<img src="http://data.biancheng.net/uploads/allimg/170927/2-1F92F92031460.png" alt="img" style="zoom:80%;" />

<center>图 1 带权图</center>


例如，在使用弗洛伊德算法计算图 1 中的任意两个顶点之间的最短路径时，具体实施步骤为：

首先，记录顶点之间初始的权值，如下表所示：

![img](http://data.biancheng.net/uploads/allimg/170927/2-1F92F9210J57.png)



依次遍历所有的顶点，假设从 V0 开始，将 V0 作为中间点，看每对顶点之间的距离值是否会更小。最终 V0 对于每对顶点之间的距离没有任何改善。

> 对于 V0 来说，由于该顶点只有出度，没有入度，所以没有作为中间点的可能。同理，V1也没有可能。


将 V2 作为每对顶点的中间点，有影响的为 （V0，V3） 和 （V1，V3）：

> 例如，（V0，V3）权值为无穷大，而（V0，V2）+（V2，V3）= 60，比之前的值小，相比而言后者的路径更短；同理 （V1，V3）也是如此。


更新的表格为：

![img](http://data.biancheng.net/uploads/allimg/170927/2-1F92F92233H6.png)


以 V3 作为中间顶点遍历各队顶点，更新后的表格为：

![img](http://data.biancheng.net/uploads/allimg/170927/2-1F92F9225O30.png)


以 V4 作为中间顶点遍历各队顶点，更新后的表格为：

![img](http://data.biancheng.net/uploads/allimg/170927/2-1F92F92310514.png)


而对于顶点 V5 来说，和顶点 V0 和 V1 相类似，所不同的是，V5 只有入度，没有出度，所以对各队顶点的距离不会产生影响。最终采用弗洛伊德算法求得的各个顶点之间的最短路径如上图所示。



#### 七 查找技术 

##### 7.1 什么是查找表  

在日常生活中，几乎每天都要进行一些查找的工作，在电话簿中查阅某个人的电话号码；在电脑的文件夹中查找某个具体的文件等等。本节主要介绍用于查找操作的数据结构——查找表。

查找表是由同一类型的数据元素构成的集合。例如电话号码簿和字典都可以看作是一张查找表。

一般对于查找表有以下几种操作：

- 在查找表中查找某个具体的数据元素；
- 在查找表中插入数据元素；
- 从查找表中删除数据元素；

###### 7.1.1 静态查找表和动态查找表

在查找表中只做查找操作，而不改动表中数据元素，称此类查找表为静态查找表；反之，在查找表中做查找操作的同时进行插入数据或者删除数据的操作，称此类表为动态查找表。

###### 7.1.2 关键字

在查找表查找某个特定元素时，前提是需要知道这个元素的一些属性。例如，每个人上学的时候都会有自己唯一的学号，因为你的姓名、年龄都有可能和其他人是重复的，唯独学号不会重复。而学生具有的这些属性（学号、姓名、年龄等）都可以称为关键字。

关键字又细分为主关键字和次关键字。若某个关键字可以唯一地识别一个数据元素时，称这个关键字为主关键字，例如学生的学号就具有唯一性；反之，像学生姓名、年龄这类的关键字，由于不具有唯一性，称为次关键字。

###### 7.1.3 如何进行查找？

不同的查找表，其使用的查找方法是不同的。例如每个人都有属于自己的朋友圈，都有自己的电话簿，电话簿中数据的排序方式是多种多样的，有的是按照姓名的首字母进行排序，这种情况在查找时，就可以根据被查找元素的首字母进行

[顺序查找](http://data.biancheng.net/view/54.html)；有的是按照类别（亲朋好友）进行排序。在查找时，就需要根据被查找元素本身的类别关键字进行排序。

> 具体的查找方法需要根据实际应用中具体情况而定。

本章从静态查找表、动态查找表和[哈希表](http://data.biancheng.net/view/63.html)的角度具体分析针对不同的查找表可供选择的查找算法。



##### 7.2 顺序查找算法 

通过前面对静态查找表的介绍，静态查找表即为只做查找操作的查找表。

静态查找表既可以使用[顺序表](http://data.biancheng.net/view/158.html)表示，也可以使用[链表](http://data.biancheng.net/view/160.html)结构表示。虽然一个是[数组](http://data.biancheng.net/view/181.html)、一个链表，但两者在做查找操作时，基本上大同小异。

> 本节以静态查找表的顺序存储结构为例做详细的介绍。

###### 7.2.1 顺序查找的实现

静态查找表用顺序存储结构表示时，顺序查找的查找过程为：从表中的最后一个数据元素开始，逐个同记录的关键字做比较，如果匹配成功，则查找成功；反之，如果直到表中第一个关键字查找完也没有成功匹配，则查找失败。

同时，在程序中初始化创建查找表时，由于是顺序存储，所以将所有的数据元素存储在数组中，但是把第一个位置留给了用户用于查找的关键字。例如，在顺序表`{1,2,3,4,5,6}`中查找数据元素值为 7 的元素，则添加后的顺序表为：

![img](http://data.biancheng.net/uploads/allimg/171016/2-1G016094604629.png)

<center>图1 顺序表中的监视哨</center>


顺序表的一端添加用户用于搜索的关键字，称作“监视哨”。

图 1 中监视哨的位置也可放在数据元素 6 的后面（这种情况下，整个查找的顺序应有逆向查找改为顺序查找）。

放置好监视哨之后，顺序表遍历从没有监视哨的一端依次进行，如果查找表中有用户需要的数据，则程序输出该位置；反之，程序会运行至监视哨，此时匹配成功，程序停止运行，但是结果是查找失败。

###### 7.2.2 顺序查找的性能分析

查找操作的性能分析主要考虑其时间复杂度，而整个查找过程其实大部分时间花费在关键字和查找表中的数据进行比较上。

所以查找算法衡量好坏的依据为：查找成功时，查找的关键字和查找表中的数据元素中进行过比较的个数的平均值，称为平均查找长度（Average Search Length，用 ASL 表示）。

例如，对于具有 n 个数据元素的查找表，查找成功的平均查找长度的计算公式为：

![img](http://data.biancheng.net/uploads/allimg/171016/2-1G016094QG24.png)

Pi 为第 i 个数据元素被查找的概率，所有元素被查找的概率的和为 1；Ci 表示在查找到第 i 个数据元素之前已进行过比较的次数。若表中有 n 个数据元素，查找第一个元素时需要比较 n 次；查找最后一个元素时需要比较 1 次，所以有 `Ci = n – i + 1` 。

一般情况，表中各数据元素被查找的概率是未知的。假设含有 n 个数据元素的查找表中，各数据被查找的概率是相同的，则：
![img](http://data.biancheng.net/uploads/allimg/171016/2-1G01609502DK.png)

换算后，得：
![img](http://data.biancheng.net/uploads/allimg/171016/2-1G016095114a4.png)

> 如果对于查找表中各个数据元素有可能被查找的概率提前已知，就应该根据其查找概率的大小对查找表中的数据元素进行适当的调整：被查找概率越大，离查找出发点 i 越近；反之，越远。这样可以适当的减少查找操作中的比较次数。

上边的平均查找长度是在假设查找算法每次都成功的前提下得出的。而对于查找算法来说，查找成功和查找失败的概率是相同的。所以，查找算法的平均查找长度应该为查找成功时的平均查找长度加上查找失败时的平均查找长度。

对于含有 n 个数据的表来说，每次查找失败，比较的次数都是 n+1。所以查找算法的平均查找长度的计算公式为：
![img](http://data.biancheng.net/uploads/allimg/171016/2-1G016095150306.png)

###### 7.2.3 总结

本节主要介绍了静态查找表的顺序存储的表示和查找算法的实现，其中使用监视哨对普通的顺序表的遍历算法做了改进，在数据量大的情况下，能够有效提高算法的运行效率。

##### 7.3 折半查找 

折半查找，也称二分查找，在某些情况下相比于[顺序查找](http://data.biancheng.net/view/54.html)，使用折半查找算法的效率更高。但是该算法的使用的前提是静态查找表中的数据必须是有序的。

例如，在`{5,21,13,19,37,75,56,64,88 ,80,92}`这个查找表使用折半查找算法查找数据之前，需要首先对该表中的数据按照所查的关键字进行排序：`{5,13,19,21,37,56,64,75,80,88,92}`。

> 在折半查找之前对查找表按照所查的关键字进行排序的意思是：若查找表中存储的数据元素含有多个关键字时，使用哪种关键字做折半查找，就需要提前以该关键字对所有数据进行排序。

###### 7.3.1 折半查找算法

对静态查找表`{5,13,19,21,37,56,64,75,80,88,92}`采用折半查找算法查找关键字为 21 的过程为：



![img](http://data.biancheng.net/uploads/allimg/171016/2-1G016102104D7.png)

<center>图 1 折半查找的过程（a)</center>


如上图 1 所示，指针 low 和 high 分别指向查找表的第一个关键字和最后一个关键字，指针 mid 指向处于 low 和 high 指针中间位置的关键字。在查找的过程中每次都同 mid 指向的关键字进行比较，由于整个表中的数据是有序的，因此在比较之后就可以知道要查找的关键字的大致位置。

例如在查找关键字 21 时，首先同 56 作比较，由于`21 < 56`，而且这个查找表是按照升序进行排序的，所以可以判定如果静态查找表中有 21 这个关键字，就一定存在于 low 和 mid 指向的区域中间。

因此，再次遍历时需要更新 high 指针和 mid 指针的位置，令 high 指针移动到 mid 指针的左侧一个位置上，同时令 mid 重新指向 low 指针和 high 指针的中间位置。如图 2 所示：



![img](http://data.biancheng.net/uploads/allimg/171016/2-1G016102250N2.png)

<center>图 2 折半查找的过程（b)</center>

同样，用 21 同 mid 指针指向的 19 作比较，`19 < 21`，所以可以判定 21 如果存在，肯定处于 mid 和 high 指向的区域中。所以令 low 指向 mid 右侧一个位置上，同时更新 mid 的位置。



![img](http://data.biancheng.net/uploads/allimg/171016/2-1G01610231cS.png)



<center>图 3 折半查找的过程（3）</center>

当第三次做判断时，发现 mid 就是关键字 21 ，查找结束。

> 注意：在做查找的过程中，如果 low 指针和 high 指针的中间位置在计算时位于两个关键字中间，即求得 mid 的位置不是整数，需要统一做取整操作。

###### 7.3.2 折半查找的性能分析

折半查找的运行过程可以用二叉树来描述，这棵[树](http://data.biancheng.net/view/23.html)通常称为“判定树”。例如图 1 中的静态查找表中做折半查找的过程，对应的判定树如图 4：

![img](http://data.biancheng.net/uploads/allimg/171016/2-1G01610244a11.png)

<center>图 4 折半查找对应的判定树 </center>


在判定树中可以看到，如果想在查找表中查找 21 的位置，只需要进行 3 次比较，依次和 56、19、21 进行比较，而比较的次数恰好是该关键字所在判定树中的层次（关键字 21 在判定树中的第 3 层）。

对于具有 n 个结点（查找表中含有 n 个关键字）的判定树，它的层次数至多为：`log2n + 1`（如果结果不是整数，则做取整操作，例如： `log211 +1 = 3 + 1 = 4` ）。

同时，在查找表中各个关键字被查找概率相同的情况下，折半查找的平均查找长度为：`ASL = log2(n+1) – 1`。

###### 7.3.3 总结

通过比较折半查找的平均查找长度，同前面介绍的顺序查找相对比，明显折半查找的效率要高。但是折半查找算法只适用于有序表，同时仅限于查找表用顺序存储结构表示。

当查找表使用链式存储结构表示时，折半查找算法无法有效地进行比较操作（排序和查找操作的实现都异常繁琐）。

































#### 八 排序技术 

##### 8.1 插入排序  

插入排序算法是所有排序方法中最简单的一种算法，其主要的实现思想是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据。

###### 8.1.1 直接插入排序

直接插入排序是插入排序算法中的一种，采用的方法是：在添加新的记录时，使用[顺序查找](http://data.biancheng.net/view/54.html)的方式找到其要插入的位置，然后将新记录插入。

> 很多初学者所说的插入排序，实际上指的就是直接插入排序算法，插入排序算法还包括折半插入排序、2-路插入排序，表插入排序和希尔排序等，后序文章都会一一讲到。

例如采用直接插入排序算法将无序表`{3,1,7,5,2,4,9,6}`进行升序排序的过程为：

- 首先考虑记录 3 ，由于插入排序刚开始，有序表中没有任何记录，所以 3 可以直接添加到有序表中，则有序表和无序表可以如图 1 所示：

![img](http://data.biancheng.net/uploads/allimg/171031/2-1G031100936450.png)

<center>图 1 直接插入排序（1)</center>

- 向有序表中插入记录 1 时，同有序表中记录 3 进行比较，1<3，所以插入到记录 3 的左侧，如图 2 所示：


![img](http://data.biancheng.net/uploads/allimg/171031/2-1G0311010064T.png)

<center>图 2 直接插入排序（2)</center>

- 向有序表插入记录 7 时，同有序表中记录 3 进行比较，3<7，所以插入到记录 3 的右侧，如图 3 所示：


![img](http://data.biancheng.net/uploads/allimg/171031/2-1G031101030I8.png)

<center>图 3 直接插入排序（3)</center>

- 向有序表中插入记录 5 时，同有序表中记录 7 进行比较，5<7，同时 5>3，所以插入到 3 和 7 中间，如图 4 所示：


![img](http://data.biancheng.net/uploads/allimg/171031/2-1G03110110b64.png)

<center>图 4 直接插入排序（4)</center>

- 向有序表插入记录 2 时，同有序表中记录 7进行比较，2<7，再同 5，3，1分别进行比较，最终确定 2 位于 1 和 3 中间，如图 5 所示：

![img](http://data.biancheng.net/uploads/allimg/171031/2-1G03110112H34.png)

<center>图 5 直接插入排序（5)</center> 

- 照此规律，依次将无序表中的记录 4，9 和 6插入到有序表中，如图 6 所示：


![img](http://data.biancheng.net/uploads/allimg/171031/2-1G031101156448.png)

<center>图 6 依次插入记录4，9和6</center> 



###### 8.1.2 折半插入排序

​	插入方式不变，查找方式改变，利用折半查找来代替顺序查找。

​	

###### 8.1.3  2路插入排序



###### 8.1.4 希尔排序 

>http://data.biancheng.net/view/69.html

希尔排序，又称“缩小增量排序”，也是插入排序的一种，但是同前面几种排序算法比较来看，希尔排序在时间效率上有很大的改进。

在使用直接[插入排序算法](http://data.biancheng.net/view/65.html)

时，如果表中的记录只有个别的是无序的，多数保持有序，这种情况下算法的效率也会比较高；除此之外，如果需要排序的记录总量很少，该算法的效率同样会很高。希尔排序就是从这两点出发对算法进行改进得到的排序算法。

> 希尔排序的具体实现思路是：先将整个记录表分割成若干部分，分别进行直接插入排序，然后再对整个记录表进行一次直接插入排序。

例如无序表`{49，38，65，97，76，13，27，49，55，4}`进行希尔排序的过程为：

- 首先对 {49，13}，{38，27}，{65，49}，{97，55}，{76，4} 分别进行直接插入排序（如果需要调换位置也只是互换存储位置），如下图所示：



![img](http://data.biancheng.net/uploads/allimg/171031/2-1G031111300510.png)

上图中两两进行比较，例如 49 和 13 进行比较，13<49，所以交换存储位置。


- 通过一次排序，无序表中的记录已基本有序，此时还可以再进行一次分割，如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171031/2-1G031111325V0.png)



- 经过两次分割，无序表中已基本有序，此时对整张表进行一次直接插入排序（只需要做少量的比较和插入操作即可），最终希尔排序的结果为：

  ​	


  ![img](http://data.biancheng.net/uploads/allimg/171031/2-1G031111351218.png)

   

希尔排序的过程中，对于分割的每个子表，其各自包含的记录在原表中并不是相互挨着的，而是相互之间相隔着某个固定的常数。例如上例中第一次排序时子表中的记录分割的常量为 5，第二次排序时为 3。

通过此种方式，对于关键字的值较小的记录，其前移的过程不是一步一步的，而是跳跃性的前移，并且在最后一次对整表进行插入排序时减少了比较和排序的次数。

> 一般在记录的数量多的情况下，希尔排序的排序效率较直接插入排序高。

希尔排序的具体代码实现：



##### 8.2 交换排序

###### 8.2.1 冒泡排序 

起泡排序，别名“冒泡排序”，该算法的核心思想是将无序表中的所有记录，通过两两比较关键字，得出升序序列或者降序序列。

例如，对无序表`{49，38，65，97，76，13，27，49}`进行升序排序的具体实现过程如图 1 所示：



![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G0305Jb.png)

图 1 第一次起泡


如图 1 所示是对无序表的第一次起泡排序，最终将无序表中的最大值 97 找到并存储在表的最后一个位置。具体实现过程为：

1. 首先 49 和 38 比较，由于 38<49，所以两者交换位置，即从（1）到（2）的转变；
2. 然后继续下标为 1 的同下标为 2 的进行比较，由于 49<65，所以不移动位置，（3）中 65 同 97 比较得知，两者也不需要移动位置；
3. 直至（4），97 同 76 进行比较，76<97，两者交换位置，如（5）所示；
4. 同样 97>13（5）、97>27（6）、97>49（7），所以经过一次冒泡排序，最终在无序表中找到一个最大值 97，第一次冒泡结束；


由于 97 已经判断为最大值，所以第二次冒泡排序时就需要找出除 97 之外的无序表中的最大值，比较过程和第一次完全相同。



![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G0321L94.png)


经过第二次冒泡，最终找到了除 97 之外的又一个最大值 76，比较过程完全一样，这里不再描述。

> 通过一趟趟的比较，一个个的“最大值”被找到并移动到相应位置，直到检测到表中数据已经有序，或者比较次数等同于表中含有记录的个数，排序结束，这就是起泡排序。

**总结** 

使用起泡排序算法，其时间复杂度同实际表中数据的无序程度有关。若表中记录本身为正序存放，则整个排序过程只需进行 n-1（n 为表中记录的个数）次比较，且不需要移动记录；若表中记录为逆序存放（最坏的情况），则需要 n-1趟排序，进行 n(n-1)/2 次比较和数据的移动。所以该算法的时间复杂度为`O(n2)`。



###### 8.2.2 快速排序

> http://data.biancheng.net/view/71.html
>
> C语言中自带函数库中就有快速排序——qsort函数 ，包含在 <stdlib.h> 头文件中。

快速排序算法是在起泡排序的基础上进行改进的一种算法，其实现的基本思想是：通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小，然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就成为了有序序列。

例如，对无序表`{49，38，65，97，76，13，27，49}`进行快速排序，大致过程为：

1. 首先从表中选取一个记录的关键字作为分割点（称为“枢轴”或者支点，一般选择第一个关键字），例如选取 49；
2. 将表格中大于 49 个放置于 49 的右侧，小于 49 的放置于 49 的左侧，假设完成后的无序表为：`{27，38，13，49，65，97，76，49}`；
3. 以 49 为支点，将整个无序表分割成了两个部分，分别为`{27，38，13}`和`{65，97，76，49}`，继续采用此种方法分别对两个子表进行排序；
4. 前部分子表以 27 为支点，排序后的子表为`{13，27，38}`，此部分已经有序；后部分子表以 65 为支点，排序后的子表为`{49，65，97，76}`；
5. 此时前半部分子表中的数据已完成排序；后部分子表继续以 65为支点，将其分割为`{49}`和`{97，76}`，前者不需排序，后者排序后的结果为`{76，97}`；
6. 通过以上几步的排序，最后由子表`{13，27，38}`、`{49}`、`{49}`、`{65}`、`{76，97}`构成有序表：`{13，27，38，49，49，65，76，97}`；


整个过程中最重要的是实现第 2 步的分割操作，具体实现过程为：



- 设置两个指针 low 和 high，分别指向无序表的表头和表尾，如下图所示：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G04923K2.png)

- 先由 high 指针从右往左依次遍历，直到找到一个比 49 小的关键字，所以 high 指针走到 27 的地方停止。找到之后将该关键字同 low 指向的关键字进行互换：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G049532B.png)

- 然后指针 low 从左往右依次遍历，直到找到一个比 49 大的关键字为止，所以 low 指针走到 65 的地方停止。同样找到后同 high 指向的关键字进行互换：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G05009508.png)

- 指针 high 继续左移，到 13 所在的位置停止（13<49），然后同 low 指向的关键字进行互换：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G05034131.png)

- 指针 low 继续右移，到 97 所在的位置停止（97>49），然后同 high 指向的关键字互换位置：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G05050L2.png)

- 指针 high 继续左移，此时两指针相遇，整个过程结束；



##### 8.3 选择排序 

###### 8.3.1 简单选择排序

该算法的实现思想为：对于具有 n 个记录的无序表遍历 n-1 次，第 i 次从无序表中第 i 个记录开始，找出后序关键字中最小的记录，然后放置在第 i 的位置上。

例如对无序表`{56，12，80，91，20}`采用简单选择排序算法进行排序，具体过程为：

- 第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G11033T5.png)

- 第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G1105KP.png)

- 第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G11112303.png)

- 第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G1112A61.png)

- 到此简单选择排序算法完成，无序表变为有序表。

###### 8.3.2  堆排序

在学习堆排序之前，首先需要了解堆的含义：在含有 n 个元素的序列中，如果序列中的元素满足下面其中一种关系时，此序列可以称之为堆。



- ki ≤ k2i 且 ki ≤ k2i+1（在 n 个记录的范围内，第 i 个关键字的值小于第 2*i 个关键字，同时也小于第 2*i+1 个关键字）
- ki ≥ k2i 且 ki ≥ k2i+1（在 n 个记录的范围内，第 i 个关键字的值大于第 2*i 个关键字，同时也大于第 2*i+1 个关键字）


对于堆的定义也可以使用完全二叉树来解释，因为在完全二叉树中第 i 个结点的左孩子恰好是第 2i 个结点，右孩子恰好是 2i+1 个结点。如果该序列可以被称为堆，则使用该序列构建的完全二叉树中，每个根结点的值都必须不小于（或者不大于）左右孩子结点的值。

以无序表`{49，38，65，97，76，13，27，49}`来讲，其对应的堆用完全二叉树来表示为：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G11P3256.png)
图 3 无序表对应的堆

> 提示：堆用完全二叉树表示时，其表示方法不唯一，但是可以确定的是树的根结点要么是无序表中的最小值，要么是最大值。

通过将无序表转化为堆，可以直接找到表中最大值或者最小值，然后将其提取出来，令剩余的记录再重建一个堆，取出次大值或者次小值，如此反复执行就可以得到一个有序序列，此过程为堆排序。

堆排序过程的代码实现需要解决两个问题：

1. 如何将得到的无序序列转化为一个堆？
2. 在输出堆顶元素之后（完全二叉树的树根结点），如何调整剩余元素构建一个新的堆？

首先先解决第 2 个问题。图 3 所示为一个完全二叉树，若去除堆顶元素，即删除二叉树的树根结点，此时用二叉树中最后一个结点 97 代替，如下图所示：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G1192WU.png)

此时由于结点 97 比左右孩子结点的值都大，破坏了堆的结构，所以需要进行调整：首先以 堆顶元素 97 同左右子树比较，同值最小的结点交换位置，即 27 和 97 交换位置：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G1194A41.png)

 

由于替代之后破坏了根结点右子树的堆结构，所以需要进行和上述一样的调整，即令 97 同 49 进行交换位置：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G12003264.png)

 

通过上述的调整，之前被破坏的堆结构又重新建立。从根结点到叶子结点的整个调整的过程，被称为“筛选”。

解决第一个问题使用的就是不断筛选的过程，如下图所示，无序表`{49，38，65，97，76，13，27，49}`初步建立的完全二叉树，如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G12041N3.png)

 

在对上图做筛选工作时，规律是从底层结点开始，一直筛选到根结点。对于具有 n 个结点的完全二叉树，筛选工作开始的结点为第 ⌊n/2⌋个结点（此结点后序都是叶子结点，无需筛选）。

所以，对于有 9 个结点的完全二叉树，筛选工作从第 4 个结点 97 开始，由于 97 > 49 ,所以需要相互交换，交换后如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G1212b35.png)

 

然后再筛选第 3 个结点 65 ，由于 65 比左右孩子结点都大，则选择一个最小的同 65 进行交换，交换后的结果为：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G1214J09.png)

 

然后筛选第 2 个结点，由于其符合要求，所以不用筛选；最后筛选根结点 49 ，同 13 进行交换，交换后的结果为：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G12204617.png)

 

交换后，发现破坏了其右子树堆的结构，所以还需要调整，最终调整后的结果为：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G12221A8.png)





##### 8.4 归并排序

>http://data.biancheng.net/view/73.html

本节介绍一种不同于插入排序和[选择排序](http://data.biancheng.net/view/72.html)的排序方法——归并排序，其排序的实现思想是先将所有的记录完全分开，然后两两合并，在合并的过程中将其排好序，最终能够得到一个完整的有序表。

例如对于含有 n 个记录的无序表，首先默认表中每个记录各为一个有序表（只不过表的长度都为 1），然后进行两两合并，使 n 个有序表变为 ⌈n/2⌉ 个长度为 2 或者 1 的有序表（例如 4 个小有序表合并为 2 个大的有序表），通过不断地进行两两合并，直到得到一个长度为 n 的有序表为止。这种归并排序方法称为：2-路归并排序。

例如对无序表`{49，38，65，97，76，13，27}`进行 2-路归并排序的过程如图 1 所示：



![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G51010T8.png)

<center>图 1 归并排序过程</center>

> 归并过程中，每次得到的新的子表本身有序，所以最终得到的为有序表。

**总结**

提示：归并排序算法在具体实现时，首先需要将整个记录表进行折半分解，直到分解为一个记录作为单独的一张表为止，然后在进行两两合并。整个过程为分而后立的过程。

归并排序算法的时间复杂度为`O(nlogn)`。该算法相比于堆排序和快速排序，其主要的优点是：当记录表中含有值相同的记录时，排序前和排序后在表中的相对位置不会改变。

例如，在记录表中记录 a 在记录 b 的前面（记录 a 和 b 的关键字的值相等），使用归并排序之后记录 a 还在记录 b 的前面。这就体现出了该排序算法的稳定性。而堆排序和快速排序都是不稳定的。

##### 8.5 分配排序 

###### 8.5.1 基数排序 

>http://data.biancheng.net/view/74.html

基数排序不同于之前所介绍的各类排序，前边介绍到的排序方法或多或少的是通过使用比较和移动记录来实现排序，而基数排序的实现不需要进行对关键字的比较，只需要对关键字进行“分配”与“收集”两种操作即可完成。

例如对无序表`{50，123，543，187，49，30，0，2，11，100}`进行基数排序，由于每个关键字都是整数数值，且其中的最大值由个位、十位和百位构成，每个数位上的数字从 0 到 9，首先将各个关键字按照其个位数字的不同进行分配分配表如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G51924160.png)

 

通过按照各关键字的个位数进行分配，按照顺序收集得到的序列变为：`{50，30，0，100，11，2，123，543，187，49}`。在该序列表的基础上，再按照各关键字的十位对各关键字进行分配，得到的分配表如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G5203O92.png)

 

由上表顺序收集得到的记录表为：`{0、100、2、11、123、30、543、49、50、187}`。在该无序表的基础上，依次将表中的记录按照其关键字的百位进行分配，得到的分配如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G521323L.png)

 

最终通过三次分配与收集，最终得到的就是一个排好序的有序表：`{0、2、11、30、49、50、100、123、187、543}`。

例子中是按照个位-十位-百位的顺序进行基数排序，此种方式是从最低位开始排序，所以被称为最低位优先法（简称“LSD法”）。

同样还可以按照百位-十位-各位的顺序进行排序，称为最高位优先法（简称“MSD法”），使用该方式进行排序同最低位优先法不同的是：当无序表中的关键字进行分配后，相当于进入了多个子序列，后序的排序工作分别在各个子序列中进行（最低位优先法每次分配与收集都是相对于整个序列表而言的）。

例如还是对`{50，123，543，187，49，30，0，2，11，100}`使用最高位优先法进行排序，首先按照百位的不同进行分配，得到的分配表为：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G52325938.png)

 

由上图所示，整个无序表被分为了 3 个子序列，序列 1 和序列 2 中含有多个关键字，序列 3 中只包含了一个关键字，最高位优先法完成排序的标准为：直到每个子序列中只有一个关键字为止，所以需要分别对两个子序列进行再分配，各自的分配表如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G52354334.png)

 

上表中，序列 1 中还有含有两个关键字的子序列，所以还需要根据个位进行分配，最终按照各子序列的顺序同样会得到一个有序表。

###### 8.5.2 桶排序 

>不确定是否要学习



##### 8.6 内部排序算法优势分析(比较)

本章介绍了以下几种常见的排序算法：

- 插入排序：直接插入排序、折半插入排序、2-路插入排序、表插入排序和希尔排序；
- 起泡排序（[冒泡排序](http://data.biancheng.net/view/70.html)）；
- 快速排序（快排）；
- [选择排序](http://data.biancheng.net/view/72.html)：简单选择排序、[树](http://data.biancheng.net/view/23.html)形选择排序和堆排序；
- 归并排序；
- 基数排序；

###### 8.6.1 时间性能上的分析

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G54150258.png)

> 上表中的简单排序包含出希尔排序之外的所有插入排序，起泡排序和简单选择排序。同时表格中的 n 表示无序表中记录的数量；基数排序中的 d 表示进行分配和收集的次数。

在上表表示的所有“简单排序算法”中，以直接[插入排序算法](http://data.biancheng.net/view/65.html)最为简单，当无序表中的记录数量 n 较小时，选择该算法为最佳排序方法。

所有的排序算法中单就平均时间性能上分析，快速排序算法最佳，其运行所需的时间最短，但其在最坏的情况下的时间性能不如堆排序和归并排序；堆排序和归并排序相比较，当无序表中记录的数量 n 较大时，归并排序所需时间比堆排序短，但是在运行过程中所需的辅助存储空间更多（以空间换时间）。

从基数排序的

时间复杂度

上分析，该算法最适用于对 n 值很大但是关键字较小的序列进行排序。

在所有基于“比较”实现的排序算法中（以上排序算法中除了基数排序，都是基于“比较”实现），其在最坏情况下能达到的最好的时间复杂度为`O(nlogn)`。

###### 8.6.2 算法稳定性

本章所介绍的所有排序算法中，选择排序、快速排序和希尔排序都不是稳定的排序算法；而冒泡排序、插入排序、归并排序和基数排序都是稳定的排序算法。

###### 8.6.3 算法实现的存储结构

本章所介绍的大多数算法都是在顺序存储结构的基础上实现的，基于顺序存储结构的局限性，排序算法在排序过程都需要进行大量记录的移动，影响算法本身的效率。

当无序表中记录的数量很大时，就需要采用

[静态链表](http://data.biancheng.net/view/163.html)

替换顺序存储结构，例如：表插入排序、链式基数排序算法，是以修改指针代替大量移动记录的方式提高算法效率。

###### 8.6.4 本章小结

通过比较所有的排序算法，没有哪一种是绝对最优的，在使用时需要根据不同的实际情况适当选择合适的排序算法，甚至可以考虑将多种排序算法结合起来使用。